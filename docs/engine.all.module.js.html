<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    
    <link rel="icon" href="./static/favicon.png" />
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      engine.all.module.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
    <style>
      .prettyprint code {font-family:monospace}
    </style>
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">LittleJS - The Tiny JavaScript Game Engine That Can!</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="9069348" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=5603290><div class="accordion-heading child"><a href="Color.html">Color</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Color.html#add">add</a></li><li data-type='method'><a href="Color.html#add">add</a></li><li data-type='method'><a href="Color.html#clamp">clamp</a></li><li data-type='method'><a href="Color.html#clamp">clamp</a></li><li data-type='method'><a href="Color.html#copy">copy</a></li><li data-type='method'><a href="Color.html#copy">copy</a></li><li data-type='method'><a href="Color.html#divide">divide</a></li><li data-type='method'><a href="Color.html#divide">divide</a></li><li data-type='method'><a href="Color.html#getHSLA">getHSLA</a></li><li data-type='method'><a href="Color.html#getHSLA">getHSLA</a></li><li data-type='method'><a href="Color.html#lerp">lerp</a></li><li data-type='method'><a href="Color.html#lerp">lerp</a></li><li data-type='method'><a href="Color.html#multiply">multiply</a></li><li data-type='method'><a href="Color.html#multiply">multiply</a></li><li data-type='method'><a href="Color.html#mutate">mutate</a></li><li data-type='method'><a href="Color.html#mutate">mutate</a></li><li data-type='method'><a href="Color.html#rgbaInt">rgbaInt</a></li><li data-type='method'><a href="Color.html#rgbaInt">rgbaInt</a></li><li data-type='method'><a href="Color.html#scale">scale</a></li><li data-type='method'><a href="Color.html#scale">scale</a></li><li data-type='method'><a href="Color.html#setHex">setHex</a></li><li data-type='method'><a href="Color.html#setHex">setHex</a></li><li data-type='method'><a href="Color.html#setHSLA">setHSLA</a></li><li data-type='method'><a href="Color.html#setHSLA">setHSLA</a></li><li data-type='method'><a href="Color.html#subtract">subtract</a></li><li data-type='method'><a href="Color.html#subtract">subtract</a></li><li data-type='method'><a href="Color.html#toString">toString</a></li><li data-type='method'><a href="Color.html#toString">toString</a></li></ul></li><li class="accordion collapsed child" id=6535264><div class="accordion-heading child"><a href="EngineObject.html">EngineObject</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="EngineObject.html#addChild">addChild</a></li><li data-type='method'><a href="EngineObject.html#addChild">addChild</a></li><li data-type='method'><a href="EngineObject.html#applyAcceleration">applyAcceleration</a></li><li data-type='method'><a href="EngineObject.html#applyAcceleration">applyAcceleration</a></li><li data-type='method'><a href="EngineObject.html#applyForce">applyForce</a></li><li data-type='method'><a href="EngineObject.html#applyForce">applyForce</a></li><li data-type='method'><a href="EngineObject.html#collideWithObject">collideWithObject</a></li><li data-type='method'><a href="EngineObject.html#collideWithObject">collideWithObject</a></li><li data-type='method'><a href="EngineObject.html#collideWithTile">collideWithTile</a></li><li data-type='method'><a href="EngineObject.html#collideWithTile">collideWithTile</a></li><li data-type='method'><a href="EngineObject.html#collideWithTileRaycast">collideWithTileRaycast</a></li><li data-type='method'><a href="EngineObject.html#collideWithTileRaycast">collideWithTileRaycast</a></li><li data-type='method'><a href="EngineObject.html#destroy">destroy</a></li><li data-type='method'><a href="EngineObject.html#destroy">destroy</a></li><li data-type='method'><a href="EngineObject.html#getAliveTime">getAliveTime</a></li><li data-type='method'><a href="EngineObject.html#getAliveTime">getAliveTime</a></li><li data-type='method'><a href="EngineObject.html#getMirrorSign">getMirrorSign</a></li><li data-type='method'><a href="EngineObject.html#getMirrorSign">getMirrorSign</a></li><li data-type='method'><a href="EngineObject.html#removeChild">removeChild</a></li><li data-type='method'><a href="EngineObject.html#removeChild">removeChild</a></li><li data-type='method'><a href="EngineObject.html#render">render</a></li><li data-type='method'><a href="EngineObject.html#render">render</a></li><li data-type='method'><a href="EngineObject.html#setCollision">setCollision</a></li><li data-type='method'><a href="EngineObject.html#setCollision">setCollision</a></li><li data-type='method'><a href="EngineObject.html#update">update</a></li><li data-type='method'><a href="EngineObject.html#update">update</a></li></ul></li><li class="accordion collapsed child" id=9231238><div class="accordion-heading child"><a href="FontImage.html">FontImage</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="FontImage.html#drawText">drawText</a></li><li data-type='method'><a href="FontImage.html#drawText">drawText</a></li><li data-type='method'><a href="FontImage.html#drawTextScreen">drawTextScreen</a></li><li data-type='method'><a href="FontImage.html#drawTextScreen">drawTextScreen</a></li></ul></li><li class="accordion collapsed child" id=1284820><div class="accordion-heading child"><a href="Medal.html">Medal</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Medal.html#render">render</a></li><li data-type='method'><a href="Medal.html#render">render</a></li><li data-type='method'><a href="Medal.html#renderIcon">renderIcon</a></li><li data-type='method'><a href="Medal.html#renderIcon">renderIcon</a></li><li data-type='method'><a href="Medal.html#unlock">unlock</a></li><li data-type='method'><a href="Medal.html#unlock">unlock</a></li></ul></li><li class="accordion collapsed child" id=7929418><div class="accordion-heading child"><a href="Music.html">Music</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Music.html#play">play</a></li><li data-type='method'><a href="Music.html#play">play</a></li></ul></li><li class="accordion collapsed child" id=1772724><div class="accordion-heading child"><a href="Newgrounds.html">Newgrounds</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Newgrounds.html#call">call</a></li><li data-type='method'><a href="Newgrounds.html#call">call</a></li><li data-type='method'><a href="Newgrounds.html#getScores">getScores</a></li><li data-type='method'><a href="Newgrounds.html#getScores">getScores</a></li><li data-type='method'><a href="Newgrounds.html#logView">logView</a></li><li data-type='method'><a href="Newgrounds.html#logView">logView</a></li><li data-type='method'><a href="Newgrounds.html#postScore">postScore</a></li><li data-type='method'><a href="Newgrounds.html#postScore">postScore</a></li><li data-type='method'><a href="Newgrounds.html#unlockMedal">unlockMedal</a></li><li data-type='method'><a href="Newgrounds.html#unlockMedal">unlockMedal</a></li></ul></li><li class="accordion collapsed child" id=1945332><div class="accordion-heading child"><a href="Particle.html">Particle</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Particle.html#addChild">addChild</a></li><li data-type='method'><a href="Particle.html#applyAcceleration">applyAcceleration</a></li><li data-type='method'><a href="Particle.html#applyForce">applyForce</a></li><li data-type='method'><a href="Particle.html#collideWithObject">collideWithObject</a></li><li data-type='method'><a href="Particle.html#collideWithTile">collideWithTile</a></li><li data-type='method'><a href="Particle.html#collideWithTileRaycast">collideWithTileRaycast</a></li><li data-type='method'><a href="Particle.html#destroy">destroy</a></li><li data-type='method'><a href="Particle.html#getAliveTime">getAliveTime</a></li><li data-type='method'><a href="Particle.html#getMirrorSign">getMirrorSign</a></li><li data-type='method'><a href="Particle.html#removeChild">removeChild</a></li><li data-type='method'><a href="Particle.html#render">render</a></li><li data-type='method'><a href="Particle.html#render">render</a></li><li data-type='method'><a href="Particle.html#setCollision">setCollision</a></li><li data-type='method'><a href="Particle.html#update">update</a></li></ul></li><li class="accordion collapsed child" id=1715927><div class="accordion-heading child"><a href="ParticleEmitter.html">ParticleEmitter</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="ParticleEmitter.html#addChild">addChild</a></li><li data-type='method'><a href="ParticleEmitter.html#applyAcceleration">applyAcceleration</a></li><li data-type='method'><a href="ParticleEmitter.html#applyForce">applyForce</a></li><li data-type='method'><a href="ParticleEmitter.html#collideWithObject">collideWithObject</a></li><li data-type='method'><a href="ParticleEmitter.html#collideWithTile">collideWithTile</a></li><li data-type='method'><a href="ParticleEmitter.html#collideWithTileRaycast">collideWithTileRaycast</a></li><li data-type='method'><a href="ParticleEmitter.html#destroy">destroy</a></li><li data-type='method'><a href="ParticleEmitter.html#emitParticle">emitParticle</a></li><li data-type='method'><a href="ParticleEmitter.html#emitParticle">emitParticle</a></li><li data-type='method'><a href="ParticleEmitter.html#getAliveTime">getAliveTime</a></li><li data-type='method'><a href="ParticleEmitter.html#getMirrorSign">getMirrorSign</a></li><li data-type='method'><a href="ParticleEmitter.html#removeChild">removeChild</a></li><li data-type='method'><a href="ParticleEmitter.html#render">render</a></li><li data-type='method'><a href="ParticleEmitter.html#setCollision">setCollision</a></li><li data-type='method'><a href="ParticleEmitter.html#update">update</a></li><li data-type='method'><a href="ParticleEmitter.html#update">update</a></li></ul></li><li class="accordion collapsed child" id=5131096><div class="accordion-heading child"><a href="Sound.html">Sound</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Sound.html#play">play</a></li><li data-type='method'><a href="Sound.html#play">play</a></li><li data-type='method'><a href="Sound.html#playNote">playNote</a></li><li data-type='method'><a href="Sound.html#playNote">playNote</a></li></ul></li><li class="accordion collapsed child" id=3025438><div class="accordion-heading child"><a href="TileLayer.html">TileLayer</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="TileLayer.html#addChild">addChild</a></li><li data-type='method'><a href="TileLayer.html#applyAcceleration">applyAcceleration</a></li><li data-type='method'><a href="TileLayer.html#applyForce">applyForce</a></li><li data-type='method'><a href="TileLayer.html#collideWithObject">collideWithObject</a></li><li data-type='method'><a href="TileLayer.html#collideWithTile">collideWithTile</a></li><li data-type='method'><a href="TileLayer.html#collideWithTileRaycast">collideWithTileRaycast</a></li><li data-type='method'><a href="TileLayer.html#destroy">destroy</a></li><li data-type='method'><a href="TileLayer.html#drawAllTileData">drawAllTileData</a></li><li data-type='method'><a href="TileLayer.html#drawAllTileData">drawAllTileData</a></li><li data-type='method'><a href="TileLayer.html#drawCanvas2D">drawCanvas2D</a></li><li data-type='method'><a href="TileLayer.html#drawCanvas2D">drawCanvas2D</a></li><li data-type='method'><a href="TileLayer.html#drawRect">drawRect</a></li><li data-type='method'><a href="TileLayer.html#drawRect">drawRect</a></li><li data-type='method'><a href="TileLayer.html#drawTile">drawTile</a></li><li data-type='method'><a href="TileLayer.html#drawTile">drawTile</a></li><li data-type='method'><a href="TileLayer.html#drawTileData">drawTileData</a></li><li data-type='method'><a href="TileLayer.html#drawTileData">drawTileData</a></li><li data-type='method'><a href="TileLayer.html#getAliveTime">getAliveTime</a></li><li data-type='method'><a href="TileLayer.html#getData">getData</a></li><li data-type='method'><a href="TileLayer.html#getData">getData</a></li><li data-type='method'><a href="TileLayer.html#getMirrorSign">getMirrorSign</a></li><li data-type='method'><a href="TileLayer.html#redraw">redraw</a></li><li data-type='method'><a href="TileLayer.html#redraw">redraw</a></li><li data-type='method'><a href="TileLayer.html#redrawEnd">redrawEnd</a></li><li data-type='method'><a href="TileLayer.html#redrawEnd">redrawEnd</a></li><li data-type='method'><a href="TileLayer.html#redrawStart">redrawStart</a></li><li data-type='method'><a href="TileLayer.html#redrawStart">redrawStart</a></li><li data-type='method'><a href="TileLayer.html#removeChild">removeChild</a></li><li data-type='method'><a href="TileLayer.html#render">render</a></li><li data-type='method'><a href="TileLayer.html#setCollision">setCollision</a></li><li data-type='method'><a href="TileLayer.html#setData">setData</a></li><li data-type='method'><a href="TileLayer.html#setData">setData</a></li><li data-type='method'><a href="TileLayer.html#update">update</a></li></ul></li><li class="accordion collapsed child" id=2763020><div class="accordion-heading child"><a href="TileLayerData.html">TileLayerData</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="TileLayerData.html#clear">clear</a></li><li data-type='method'><a href="TileLayerData.html#clear">clear</a></li></ul></li><li class="accordion collapsed child" id=8096281><div class="accordion-heading child"><a href="Timer.html">Timer</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Timer.html#active">active</a></li><li data-type='method'><a href="Timer.html#active">active</a></li><li data-type='method'><a href="Timer.html#elapsed">elapsed</a></li><li data-type='method'><a href="Timer.html#elapsed">elapsed</a></li><li data-type='method'><a href="Timer.html#get">get</a></li><li data-type='method'><a href="Timer.html#get">get</a></li><li data-type='method'><a href="Timer.html#getPercent">getPercent</a></li><li data-type='method'><a href="Timer.html#getPercent">getPercent</a></li><li data-type='method'><a href="Timer.html#isSet">isSet</a></li><li data-type='method'><a href="Timer.html#isSet">isSet</a></li><li data-type='method'><a href="Timer.html#set">set</a></li><li data-type='method'><a href="Timer.html#set">set</a></li><li data-type='method'><a href="Timer.html#toString">toString</a></li><li data-type='method'><a href="Timer.html#toString">toString</a></li><li data-type='method'><a href="Timer.html#unset">unset</a></li><li data-type='method'><a href="Timer.html#unset">unset</a></li><li data-type='method'><a href="Timer.html#valueOf">valueOf</a></li><li data-type='method'><a href="Timer.html#valueOf">valueOf</a></li></ul></li><li class="accordion collapsed child" id=8807844><div class="accordion-heading child"><a href="Vector2.html">Vector2</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Vector2.html#add">add</a></li><li data-type='method'><a href="Vector2.html#add">add</a></li><li data-type='method'><a href="Vector2.html#angle">angle</a></li><li data-type='method'><a href="Vector2.html#angle">angle</a></li><li data-type='method'><a href="Vector2.html#area">area</a></li><li data-type='method'><a href="Vector2.html#area">area</a></li><li data-type='method'><a href="Vector2.html#arrayCheck">arrayCheck</a></li><li data-type='method'><a href="Vector2.html#arrayCheck">arrayCheck</a></li><li data-type='method'><a href="Vector2.html#clampLength">clampLength</a></li><li data-type='method'><a href="Vector2.html#clampLength">clampLength</a></li><li data-type='method'><a href="Vector2.html#copy">copy</a></li><li data-type='method'><a href="Vector2.html#copy">copy</a></li><li data-type='method'><a href="Vector2.html#cross">cross</a></li><li data-type='method'><a href="Vector2.html#cross">cross</a></li><li data-type='method'><a href="Vector2.html#direction">direction</a></li><li data-type='method'><a href="Vector2.html#direction">direction</a></li><li data-type='method'><a href="Vector2.html#distance">distance</a></li><li data-type='method'><a href="Vector2.html#distance">distance</a></li><li data-type='method'><a href="Vector2.html#distanceSquared">distanceSquared</a></li><li data-type='method'><a href="Vector2.html#distanceSquared">distanceSquared</a></li><li data-type='method'><a href="Vector2.html#divide">divide</a></li><li data-type='method'><a href="Vector2.html#divide">divide</a></li><li data-type='method'><a href="Vector2.html#dot">dot</a></li><li data-type='method'><a href="Vector2.html#dot">dot</a></li><li data-type='method'><a href="Vector2.html#floor">floor</a></li><li data-type='method'><a href="Vector2.html#floor">floor</a></li><li data-type='method'><a href="Vector2.html#invert">invert</a></li><li data-type='method'><a href="Vector2.html#invert">invert</a></li><li data-type='method'><a href="Vector2.html#length">length</a></li><li data-type='method'><a href="Vector2.html#length">length</a></li><li data-type='method'><a href="Vector2.html#lengthSquared">lengthSquared</a></li><li data-type='method'><a href="Vector2.html#lengthSquared">lengthSquared</a></li><li data-type='method'><a href="Vector2.html#lerp">lerp</a></li><li data-type='method'><a href="Vector2.html#lerp">lerp</a></li><li data-type='method'><a href="Vector2.html#multiply">multiply</a></li><li data-type='method'><a href="Vector2.html#multiply">multiply</a></li><li data-type='method'><a href="Vector2.html#normalize">normalize</a></li><li data-type='method'><a href="Vector2.html#normalize">normalize</a></li><li data-type='method'><a href="Vector2.html#rotate">rotate</a></li><li data-type='method'><a href="Vector2.html#rotate">rotate</a></li><li data-type='method'><a href="Vector2.html#scale">scale</a></li><li data-type='method'><a href="Vector2.html#scale">scale</a></li><li data-type='method'><a href="Vector2.html#setAngle">setAngle</a></li><li data-type='method'><a href="Vector2.html#setAngle">setAngle</a></li><li data-type='method'><a href="Vector2.html#subtract">subtract</a></li><li data-type='method'><a href="Vector2.html#subtract">subtract</a></li><li data-type='method'><a href="Vector2.html#toString">toString</a></li><li data-type='method'><a href="Vector2.html#toString">toString</a></li></ul></li></ul> </div><div class="accordion collapsed" id="7538627" > <h3 class="accordion-heading">Namespaces<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=8402913><div class="accordion-heading child"><a href="Debug.html">Debug</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Debug.html#.debugAABB">debugAABB</a></li><li data-type='method'><a href="Debug.html#.debugAABB">debugAABB</a></li><li data-type='method'><a href="Debug.html#.debugCircle">debugCircle</a></li><li data-type='method'><a href="Debug.html#.debugCircle">debugCircle</a></li><li data-type='method'><a href="Debug.html#.debugClear">debugClear</a></li><li data-type='method'><a href="Debug.html#.debugClear">debugClear</a></li><li data-type='method'><a href="Debug.html#.debugLine">debugLine</a></li><li data-type='method'><a href="Debug.html#.debugLine">debugLine</a></li><li data-type='method'><a href="Debug.html#.debugPoint">debugPoint</a></li><li data-type='method'><a href="Debug.html#.debugPoint">debugPoint</a></li><li data-type='method'><a href="Debug.html#.debugRect">debugRect</a></li><li data-type='method'><a href="Debug.html#.debugRect">debugRect</a></li><li data-type='method'><a href="Debug.html#.debugSaveCanvas">debugSaveCanvas</a></li><li data-type='method'><a href="Debug.html#.debugSaveCanvas">debugSaveCanvas</a></li><li data-type='method'><a href="Debug.html#.debugText">debugText</a></li><li data-type='method'><a href="Debug.html#.debugText">debugText</a></li></ul></li><li class="accordion collapsed child" id=8749223><div class="accordion-heading child"><a href="Draw.html">Draw</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Draw.html#.drawCanvas2D">drawCanvas2D</a></li><li data-type='method'><a href="Draw.html#.drawCanvas2D">drawCanvas2D</a></li><li data-type='method'><a href="Draw.html#.drawLine">drawLine</a></li><li data-type='method'><a href="Draw.html#.drawLine">drawLine</a></li><li data-type='method'><a href="Draw.html#.drawRect">drawRect</a></li><li data-type='method'><a href="Draw.html#.drawRect">drawRect</a></li><li data-type='method'><a href="Draw.html#.drawRectScreenSpace">drawRectScreenSpace</a></li><li data-type='method'><a href="Draw.html#.drawRectScreenSpace">drawRectScreenSpace</a></li><li data-type='method'><a href="Draw.html#.drawText">drawText</a></li><li data-type='method'><a href="Draw.html#.drawText">drawText</a></li><li data-type='method'><a href="Draw.html#.drawTextScreen">drawTextScreen</a></li><li data-type='method'><a href="Draw.html#.drawTextScreen">drawTextScreen</a></li><li data-type='method'><a href="Draw.html#.drawTile">drawTile</a></li><li data-type='method'><a href="Draw.html#.drawTile">drawTile</a></li><li data-type='method'><a href="Draw.html#.drawTileScreenSpace">drawTileScreenSpace</a></li><li data-type='method'><a href="Draw.html#.drawTileScreenSpace">drawTileScreenSpace</a></li><li data-type='method'><a href="Draw.html#.isFullscreen">isFullscreen</a></li><li data-type='method'><a href="Draw.html#.isFullscreen">isFullscreen</a></li><li data-type='method'><a href="Draw.html#.screenToWorld">screenToWorld</a></li><li data-type='method'><a href="Draw.html#.screenToWorld">screenToWorld</a></li><li data-type='method'><a href="Draw.html#.setBlendMode">setBlendMode</a></li><li data-type='method'><a href="Draw.html#.setBlendMode">setBlendMode</a></li><li data-type='method'><a href="Draw.html#.toggleFullscreen">toggleFullscreen</a></li><li data-type='method'><a href="Draw.html#.toggleFullscreen">toggleFullscreen</a></li><li data-type='method'><a href="Draw.html#.worldToScreen">worldToScreen</a></li><li data-type='method'><a href="Draw.html#.worldToScreen">worldToScreen</a></li></ul></li><li class="accordion collapsed child" id=7284516><div class="accordion-heading child"><a href="Input.html">Input</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Input.html#.clearInput">clearInput</a></li><li data-type='method'><a href="Input.html#.clearInput">clearInput</a></li><li data-type='method'><a href="Input.html#.gamepadIsDown">gamepadIsDown</a></li><li data-type='method'><a href="Input.html#.gamepadIsDown">gamepadIsDown</a></li><li data-type='method'><a href="Input.html#.gamepadStick">gamepadStick</a></li><li data-type='method'><a href="Input.html#.gamepadStick">gamepadStick</a></li><li data-type='method'><a href="Input.html#.gamepadWasPressed">gamepadWasPressed</a></li><li data-type='method'><a href="Input.html#.gamepadWasPressed">gamepadWasPressed</a></li><li data-type='method'><a href="Input.html#.gamepadWasReleased">gamepadWasReleased</a></li><li data-type='method'><a href="Input.html#.gamepadWasReleased">gamepadWasReleased</a></li><li data-type='method'><a href="Input.html#.keyIsDown">keyIsDown</a></li><li data-type='method'><a href="Input.html#.keyIsDown">keyIsDown</a></li><li data-type='method'><a href="Input.html#.keyWasPressed">keyWasPressed</a></li><li data-type='method'><a href="Input.html#.keyWasPressed">keyWasPressed</a></li><li data-type='method'><a href="Input.html#.keyWasReleased">keyWasReleased</a></li><li data-type='method'><a href="Input.html#.keyWasReleased">keyWasReleased</a></li><li data-type='method'><a href="Input.html#.vibrate">vibrate</a></li><li data-type='method'><a href="Input.html#.vibrate">vibrate</a></li><li data-type='method'><a href="Input.html#.vibrateStop">vibrateStop</a></li><li data-type='method'><a href="Input.html#.vibrateStop">vibrateStop</a></li></ul></li><li class="accordion collapsed child" id=3819586><div class="accordion-heading child"><a href="Medals.html">Medals</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Medals.html#.medalsInit">medalsInit</a></li><li data-type='method'><a href="Medals.html#.medalsInit">medalsInit</a></li><li data-type='method'><a href="Medals.html#.newgroundsInit">newgroundsInit</a></li><li data-type='method'><a href="Medals.html#.newgroundsInit">newgroundsInit</a></li></ul></li><li class="accordion collapsed child" id=1394755><div class="accordion-heading child"><a href="Random.html">Random</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Random.html#.rand">rand</a></li><li data-type='method'><a href="Random.html#.rand">rand</a></li><li data-type='method'><a href="Random.html#.randColor">randColor</a></li><li data-type='method'><a href="Random.html#.randColor">randColor</a></li><li data-type='method'><a href="Random.html#.randInCircle">randInCircle</a></li><li data-type='method'><a href="Random.html#.randInCircle">randInCircle</a></li><li data-type='method'><a href="Random.html#.randInt">randInt</a></li><li data-type='method'><a href="Random.html#.randInt">randInt</a></li><li data-type='method'><a href="Random.html#.randSeeded">randSeeded</a></li><li data-type='method'><a href="Random.html#.randSeeded">randSeeded</a></li><li data-type='method'><a href="Random.html#.randSign">randSign</a></li><li data-type='method'><a href="Random.html#.randSign">randSign</a></li><li data-type='method'><a href="Random.html#.randVector">randVector</a></li><li data-type='method'><a href="Random.html#.randVector">randVector</a></li></ul></li><li class="accordion-list" id=""><a href="Settings.html">Settings</a></li><li class="accordion collapsed child" id=8256718><div class="accordion-heading child"><a href="TileCollision.html">TileCollision</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="TileCollision.html#.getTileCollisionData">getTileCollisionData</a></li><li data-type='method'><a href="TileCollision.html#.getTileCollisionData">getTileCollisionData</a></li><li data-type='method'><a href="TileCollision.html#.initTileCollision">initTileCollision</a></li><li data-type='method'><a href="TileCollision.html#.initTileCollision">initTileCollision</a></li><li data-type='method'><a href="TileCollision.html#.setTileCollisionData">setTileCollisionData</a></li><li data-type='method'><a href="TileCollision.html#.setTileCollisionData">setTileCollisionData</a></li><li data-type='method'><a href="TileCollision.html#.tileCollisionRaycast">tileCollisionRaycast</a></li><li data-type='method'><a href="TileCollision.html#.tileCollisionRaycast">tileCollisionRaycast</a></li><li data-type='method'><a href="TileCollision.html#.tileCollisionTest">tileCollisionTest</a></li><li data-type='method'><a href="TileCollision.html#.tileCollisionTest">tileCollisionTest</a></li></ul></li><li class="accordion collapsed child" id=2426502><div class="accordion-heading child"><a href="Utilities.html">Utilities</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Utilities.html#.abs">abs</a></li><li data-type='method'><a href="Utilities.html#.abs">abs</a></li><li data-type='method'><a href="Utilities.html#.clamp">clamp</a></li><li data-type='method'><a href="Utilities.html#.clamp">clamp</a></li><li data-type='method'><a href="Utilities.html#.colorHSLA">colorHSLA</a></li><li data-type='method'><a href="Utilities.html#.colorHSLA">colorHSLA</a></li><li data-type='method'><a href="Utilities.html#.colorRGBA">colorRGBA</a></li><li data-type='method'><a href="Utilities.html#.colorRGBA">colorRGBA</a></li><li data-type='method'><a href="Utilities.html#.formatTime">formatTime</a></li><li data-type='method'><a href="Utilities.html#.formatTime">formatTime</a></li><li data-type='method'><a href="Utilities.html#.isOverlapping">isOverlapping</a></li><li data-type='method'><a href="Utilities.html#.isOverlapping">isOverlapping</a></li><li data-type='method'><a href="Utilities.html#.lerp">lerp</a></li><li data-type='method'><a href="Utilities.html#.lerp">lerp</a></li><li data-type='method'><a href="Utilities.html#.max">max</a></li><li data-type='method'><a href="Utilities.html#.max">max</a></li><li data-type='method'><a href="Utilities.html#.min">min</a></li><li data-type='method'><a href="Utilities.html#.min">min</a></li><li data-type='method'><a href="Utilities.html#.mod">mod</a></li><li data-type='method'><a href="Utilities.html#.mod">mod</a></li><li data-type='method'><a href="Utilities.html#.nearestPowerOfTwo">nearestPowerOfTwo</a></li><li data-type='method'><a href="Utilities.html#.nearestPowerOfTwo">nearestPowerOfTwo</a></li><li data-type='method'><a href="Utilities.html#.percent">percent</a></li><li data-type='method'><a href="Utilities.html#.percent">percent</a></li><li data-type='method'><a href="Utilities.html#.sign">sign</a></li><li data-type='method'><a href="Utilities.html#.sign">sign</a></li><li data-type='method'><a href="Utilities.html#.smoothStep">smoothStep</a></li><li data-type='method'><a href="Utilities.html#.smoothStep">smoothStep</a></li><li data-type='method'><a href="Utilities.html#.vec2">vec2</a></li><li data-type='method'><a href="Utilities.html#.vec2">vec2</a></li><li data-type='method'><a href="Utilities.html#.wave">wave</a></li><li data-type='method'><a href="Utilities.html#.wave">wave</a></li></ul></li><li class="accordion collapsed child" id=7232294><div class="accordion-heading child"><a href="WebGL.html">WebGL</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="WebGL.html#.glCompileShader">glCompileShader</a></li><li data-type='method'><a href="WebGL.html#.glCompileShader">glCompileShader</a></li><li data-type='method'><a href="WebGL.html#.glCopyToContext">glCopyToContext</a></li><li data-type='method'><a href="WebGL.html#.glCopyToContext">glCopyToContext</a></li><li data-type='method'><a href="WebGL.html#.glCreateProgram">glCreateProgram</a></li><li data-type='method'><a href="WebGL.html#.glCreateProgram">glCreateProgram</a></li><li data-type='method'><a href="WebGL.html#.glCreateTexture">glCreateTexture</a></li><li data-type='method'><a href="WebGL.html#.glCreateTexture">glCreateTexture</a></li><li data-type='method'><a href="WebGL.html#.glDraw">glDraw</a></li><li data-type='method'><a href="WebGL.html#.glDraw">glDraw</a></li><li data-type='method'><a href="WebGL.html#.glFlush">glFlush</a></li><li data-type='method'><a href="WebGL.html#.glFlush">glFlush</a></li><li data-type='method'><a href="WebGL.html#.glInitPostProcess">glInitPostProcess</a></li><li data-type='method'><a href="WebGL.html#.glInitPostProcess">glInitPostProcess</a></li><li data-type='method'><a href="WebGL.html#.glSetBlendMode">glSetBlendMode</a></li><li data-type='method'><a href="WebGL.html#.glSetBlendMode">glSetBlendMode</a></li><li data-type='method'><a href="WebGL.html#.glSetTexture">glSetTexture</a></li><li data-type='method'><a href="WebGL.html#.glSetTexture">glSetTexture</a></li></ul></li></ul> </div><div class="accordion collapsed" id="3274874" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#engineFontImage">engineFontImage</a></li><li class="accordion-list" id=""><a href="global.html#engineInit">engineInit</a></li><li class="accordion-list" id=""><a href="global.html#engineName">engineName</a></li><li class="accordion-list" id=""><a href="global.html#engineObjects">engineObjects</a></li><li class="accordion-list" id=""><a href="global.html#engineObjectsCallback">engineObjectsCallback</a></li><li class="accordion-list" id=""><a href="global.html#engineObjectsCollide">engineObjectsCollide</a></li><li class="accordion-list" id=""><a href="global.html#engineObjectsDestroy">engineObjectsDestroy</a></li><li class="accordion-list" id=""><a href="global.html#engineObjectsUpdate">engineObjectsUpdate</a></li><li class="accordion-list" id=""><a href="global.html#engineVersion">engineVersion</a></li><li class="accordion-list" id=""><a href="global.html#frame">frame</a></li><li class="accordion-list" id=""><a href="global.html#frameRate">frameRate</a></li><li class="accordion-list" id=""><a href="global.html#paused">paused</a></li><li class="accordion-list" id=""><a href="global.html#time">time</a></li><li class="accordion-list" id=""><a href="global.html#timeDelta">timeDelta</a></li><li class="accordion-list" id=""><a href="global.html#timeReal">timeReal</a></li></ul> </div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        engine.all.module.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
    LittleJS - Debug Build
    MIT License - Copyright 2021 Frank Force
*/

/** 
 * LittleJS Debug System
 * &lt;br> - Press ~ to show debug overlay with mouse pick
 * &lt;br> - Number keys toggle debug functions
 * &lt;br> - +/- apply time scale
 * &lt;br> - Debug primitive rendering
 * &lt;br> - Save a 2d canvas as an image
 * @namespace Debug
 */

'use strict';

/** True if debug is enabled
 *  @default
 *  @memberof Debug */
const debug = 1;

/** True if asserts are enaled
 *  @default
 *  @memberof Debug */
const enableAsserts = 1;

/** Size to render debug points by default
 *  @default
 *  @memberof Debug */
const debugPointSize = .5;

/** True if watermark with FPS should be down, false in release builds
 *  @default
 *  @memberof Debug */
let showWatermark = 1;

/** True if god mode is enabled, handle this however you want
 *  @default
 *  @memberof Debug */
let godMode = 0;

// Engine internal variables not exposed to documentation
let debugPrimitives = [], debugOverlay = 0, debugPhysics = 0, debugRaycast = 0,
debugParticles = 0, debugGamepads = 0, debugMedals = 0, debugTakeScreenshot, downloadLink;

///////////////////////////////////////////////////////////////////////////////
// Debug helper functions

/** Asserts if the experssion is false, does not do anything in release builds
 *  @param {Boolean} assertion
 *  @param {Object}  output
 *  @memberof Debug */
const ASSERT = enableAsserts ? (...assert)=> console.assert(...assert) : ()=>{};

/** Draw a debug rectangle in world space
 *  @param {Vector2} pos
 *  @param {Vector2} [size=new Vector2()]
 *  @param {String}  [color='#fff']
 *  @param {Number}  [time=0]
 *  @param {Number}  [angle=0]
 *  @param {Boolean} [fill=0]
 *  @memberof Debug */
const debugRect = (pos, size=vec2(), color='#fff', time=0, angle=0, fill=0)=> 
{
    ASSERT(typeof color == 'string'); // pass in regular html strings as colors
    debugPrimitives.push({pos, size:vec2(size), color, time:new Timer(time), angle, fill});
}

/** Draw a debug circle in world space
 *  @param {Vector2} pos
 *  @param {Number}  [radius=0]
 *  @param {String}  [color='#fff']
 *  @param {Number}  [time=0]
 *  @param {Boolean} [fill=0]
 *  @memberof Debug */
const debugCircle = (pos, radius=0, color='#fff', time=0, fill=0)=>
{
    ASSERT(typeof color == 'string'); // pass in regular html strings as colors
    debugPrimitives.push({pos, size:radius, color, time:new Timer(time), angle:0, fill});
}

/** Draw a debug point in world space
 *  @param {Vector2} pos
 *  @param {String}  [color='#fff']
 *  @param {Number}  [time=0]
 *  @param {Number}  [angle=0]
 *  @memberof Debug */
const debugPoint = (pos, color, time, angle)=> debugRect(pos, 0, color, time, angle);

/** Draw a debug line in world space
 *  @param {Vector2} posA
 *  @param {Vector2} posB
 *  @param {String}  [color='#fff']
 *  @param {Number}  [thickness=.1]
 *  @param {Number}  [time=0]
 *  @memberof Debug */
const debugLine = (posA, posB, color, thickness=.1, time)=>
{
    const halfDelta = vec2((posB.x - posA.x)/2, (posB.y - posA.y)/2);
    const size = vec2(thickness, halfDelta.length()*2);
    debugRect(posA.add(halfDelta), size, color, time, halfDelta.angle(), 1);
}

/** Draw a debug axis aligned bounding box in world space
 *  @param {Vector2} posA
 *  @param {Vector2} sizeA
 *  @param {Vector2} posB
 *  @param {Vector2} sizeB
 *  @param {String}  [color='#fff']
 *  @memberof Debug */
const debugAABB = (pA, sA, pB, sB, color)=>
{
    const minPos = vec2(min(pA.x - sA.x/2, pB.x - sB.x/2), min(pA.y - sA.y/2, pB.y - sB.y/2));
    const maxPos = vec2(max(pA.x + sA.x/2, pB.x + sB.x/2), max(pA.y + sA.y/2, pB.y + sB.y/2));
    debugRect(minPos.lerp(maxPos,.5), maxPos.subtract(minPos), color);
}

/** Draw a debug axis aligned bounding box in world space
 *  @param {String}  text
 *  @param {Vector2} pos
 *  @param {Number}  [size=1]
 *  @param {String}  [color='#fff']
 *  @param {Number}  [time=0]
 *  @param {Number}  [angle=0]
 *  @param {String}  [font='monospace']
 *  @memberof Debug */
const debugText = (text, pos, size=1, color='#fff', time=0, angle=0, font='monospace')=> 
{
    ASSERT(typeof color == 'string'); // pass in regular html strings as colors
    debugPrimitives.push({text, pos, size, color, time:new Timer(time), angle, font});
}

/** Clear all debug primitives in the list
 *  @memberof Debug */
const debugClear = ()=> debugPrimitives = [];

/** Save a canvas to disk 
 *  @param {HTMLCanvasElement} canvas
 *  @param {String}            [filename]
 *  @memberof Debug */
const debugSaveCanvas = (canvas, filename = engineName + '.png') =>
{
    downloadLink.download = 'screenshot.png';
    downloadLink.href = canvas.toDataURL('image/png').replace('image/png','image/octet-stream');
    downloadLink.click();
}

///////////////////////////////////////////////////////////////////////////////
// Engine debug function (called automatically)

const debugInit = ()=>
{
    // create link for saving screenshots
    document.body.appendChild(downloadLink = document.createElement('a'));
    downloadLink.style.display = 'none';
}

const debugUpdate = ()=>
{
    if (!debug)
        return;

    if (keyWasPressed(192)) // ~
        debugOverlay = !debugOverlay;
    if (debugOverlay)
    {
        if (keyWasPressed(48)) // 0
            showWatermark = !showWatermark;
        if (keyWasPressed(49)) // 1
            debugPhysics = !debugPhysics, debugParticles = 0;
        if (keyWasPressed(50)) // 2
            debugParticles = !debugParticles, debugPhysics = 0;
        if (keyWasPressed(51)) // 3
            debugGamepads = !debugGamepads;
        if (keyWasPressed(52)) // 4
            godMode = !godMode;
        if (keyWasPressed(53)) // 5
            debugTakeScreenshot = 1;
        //if (keyWasPressed(54)) // 6
        //if (keyWasPressed(55)) // 7
        //if (keyWasPressed(56)) // 8
        //if (keyWasPressed(57)) // 9
    }
}

const debugRender = ()=>
{
    glCopyToContext(mainContext);

    if (debugTakeScreenshot)
    {
        // composite canvas
        glCopyToContext(mainContext, 1);
        mainContext.drawImage(overlayCanvas, 0, 0);
        overlayCanvas.width |= 0;

        debugSaveCanvas(mainCanvas);
        debugTakeScreenshot = 0;
    }

    if (debugGamepads &amp;&amp; gamepadsEnable &amp;&amp; navigator.getGamepads)
    {
        // gamepad debug display
        const gamepads = navigator.getGamepads();
        for (let i = gamepads.length; i--;)
        {
            const gamepad = gamepads[i];
            if (gamepad)
            {
                const stickScale = 1;
                const buttonScale = .2;
                const centerPos = cameraPos;
                const sticks = stickData[i];
                for (let j = sticks.length; j--;)
                {
                    const drawPos = centerPos.add(vec2(j*stickScale*2, i*stickScale*3));
                    const stickPos = drawPos.add(sticks[j].scale(stickScale));
                    debugCircle(drawPos, stickScale, '#fff7',0,1);
                    debugLine(drawPos, stickPos, '#f00');
                    debugPoint(stickPos, '#f00');
                }
                for (let j = gamepad.buttons.length; j--;)
                {
                    const drawPos = centerPos.add(vec2(j*buttonScale*2, i*stickScale*3-stickScale-buttonScale));
                    const pressed = gamepad.buttons[j].pressed;
                    debugCircle(drawPos, buttonScale, pressed ? '#f00' : '#fff7', 0, 1);
                    debugText(j, drawPos, .2);
                }
            }
        }
    }

    if (debugOverlay)
    {
        const saveContext = mainContext;
        mainContext = overlayContext;

        // mouse pick
        let bestDistance = Infinity, bestObject;
        for (const o of engineObjects)
        {
            if (o.canvas || o.destroyed)
                continue;
            if (!o.size.x || !o.size.y)
                continue;

            const distance = mousePos.distanceSquared(o.pos);
            if (distance &lt; bestDistance)
            {
                bestDistance = distance;
                bestObject = o;
            }

            // show object info
            const size = vec2(max(o.size.x, .2), max(o.size.y, .2));
            const color1 = new Color(!!o.collideTiles, !!o.collideSolidObjects, !!o.isSolid, o.parent?.2:.5);
            const color2 = o.parent ? new Color(1,1,1,.5) : new Color(0,0,0,.8);
            drawRect(o.pos, size, color1, o.angle, 0);
            drawRect(o.pos, size.scale(.8), color2, o.angle, 0);
            o.parent &amp;&amp; drawLine(o.pos, o.parent.pos, .1, new Color(0,0,1,.5), 0);
        }
        
        if (bestObject)
        {
            const raycastHitPos = tileCollisionRaycast(bestObject.pos, mousePos);
            raycastHitPos &amp;&amp; drawRect(raycastHitPos.floor().add(vec2(.5)), vec2(1), new Color(0,1,1,.3));
            drawRect(mousePos.floor().add(vec2(.5)), vec2(1), new Color(0,0,1,.5), 0, 0);
            drawLine(mousePos, bestObject.pos, .1, raycastHitPos ? new Color(1,0,0,.5) : new Color(0,1,0,.5), 0);

            const debugText = 'mouse pos = ' + mousePos + 
                '\nmouse collision = ' + getTileCollisionData(mousePos) + 
                '\n\n--- object info ---\n' +
                bestObject.toString();
            drawTextScreen(debugText, mousePosScreen, 24, new Color, .05, 0, 0, 'monospace');
        }

        glCopyToContext(mainContext = saveContext);
    }

    {
        // draw debug primitives
        overlayContext.lineWidth = 2;
        const pointSize = debugPointSize * cameraScale;
        debugPrimitives.forEach(p=>
        {
            overlayContext.save();

            // create canvas transform from world space to screen space
            const pos = worldToScreen(p.pos);
            overlayContext.translate(pos.x|0, pos.y|0);
            overlayContext.rotate(p.angle);
            overlayContext.fillStyle = overlayContext.strokeStyle = p.color;

            if (p.text != undefined)
            {
                overlayContext.font = p.size*cameraScale + 'px '+ p.font;
                overlayContext.textAlign = 'center';
                overlayContext.textBaseline = 'middle';
                overlayContext.fillText(p.text, 0, 0);
            }
            else if (p.size == 0 || p.size.x === 0 &amp;&amp; p.size.y === 0 )
            {
                // point
                overlayContext.fillRect(-pointSize/2, -1, pointSize, 3);
                overlayContext.fillRect(-1, -pointSize/2, 3, pointSize);
            }
            else if (p.size.x != undefined)
            {
                // rect
                const w = p.size.x*cameraScale|0, h = p.size.y*cameraScale|0;
                p.fill &amp;&amp; overlayContext.fillRect(-w/2|0, -h/2|0, w, h);
                overlayContext.strokeRect(-w/2|0, -h/2|0, w, h);
            }
            else
            {
                // circle
                overlayContext.beginPath();
                overlayContext.arc(0, 0, p.size*cameraScale, 0, 9);
                p.fill &amp;&amp; overlayContext.fill();
                overlayContext.stroke();
            }
            
            overlayContext.restore();
        });

        // remove expired pritives
        debugPrimitives = debugPrimitives.filter(r=>r.time&lt;0);
    }

    {
        // draw debug overlay
        overlayContext.save();
        overlayContext.fillStyle = '#fff';
        overlayContext.textAlign = 'left';
        overlayContext.textBaseline = 'top';
        overlayContext.font = '28px monospace';
        overlayContext.shadowColor = '#000';
        overlayContext.shadowBlur = 9;

        let x = 9, y = -20, h = 30;
        if (debugOverlay)
        {
            overlayContext.fillText(engineName, x, y += h);
            overlayContext.fillText('Objects: ' + engineObjects.length, x, y += h);
            overlayContext.fillText('Time: ' + formatTime(time), x, y += h);
            overlayContext.fillText('---------', x, y += h);
            overlayContext.fillStyle = '#f00';
            overlayContext.fillText('~: Debug Overlay', x, y += h);
            overlayContext.fillStyle = debugPhysics ? '#f00' : '#fff';
            overlayContext.fillText('1: Debug Physics', x, y += h);
            overlayContext.fillStyle = debugParticles ? '#f00' : '#fff';
            overlayContext.fillText('2: Debug Particles', x, y += h);
            overlayContext.fillStyle = debugGamepads ? '#f00' : '#fff';
            overlayContext.fillText('3: Debug Gamepads', x, y += h);
            overlayContext.fillStyle = godMode ? '#f00' : '#fff';
            overlayContext.fillText('4: God Mode', x, y += h);
            overlayContext.fillStyle = '#fff';
            overlayContext.fillText('5: Save Screenshot', x, y += h);

            let keysPressed = '';
            for(const i in inputData[0])
            {
                if (i &amp;&amp; keyIsDown(i, 0))
                    keysPressed += i + ' ' ;
            }
            keysPressed &amp;&amp; overlayContext.fillText('Keys Down: ' + keysPressed, x, y += h);

            let buttonsPressed = '';
            if (inputData[1])
            for(const i in inputData[1])
            {
                if (i &amp;&amp; keyIsDown(i, 1))
                    buttonsPressed += i + ' ' ;
            }
            buttonsPressed &amp;&amp; overlayContext.fillText('Gamepad: ' + buttonsPressed, x, y += h);
        }
        else
        {
            overlayContext.fillText(debugPhysics ? 'Debug Physics' : '', x, y += h);
            overlayContext.fillText(debugParticles ? 'Debug Particles' : '', x, y += h);
            overlayContext.fillText(godMode ? 'God Mode' : '', x, y += h);
            overlayContext.fillText(debugGamepads ? 'Debug Gamepads' : '', x, y += h);
        }
    
        overlayContext.restore();
    }
}
/**
 * LittleJS Utility Classes and Functions
 * &lt;br> - General purpose math library
 * &lt;br> - Vector2 - fast, simple, easy 2D vector class
 * &lt;br> - Color - holds a rgba color with some math functions
 * &lt;br> - Timer - tracks time automatically
 * @namespace Utilities
 */

'use strict';

/** A shortcut to get Math.PI
 *  @const
 *  @memberof Utilities */
const PI = Math.PI;

/** Returns absoulte value of value passed in
 *  @param {Number} value
 *  @return {Number}
 *  @memberof Utilities */
const abs = (a)=> a &lt; 0 ? -a : a;

/** Returns lowest of two values passed in
 *  @param {Number} valueA
 *  @param {Number} valueB
 *  @return {Number}
 *  @memberof Utilities */
const min = (a, b)=> a &lt; b ?  a : b;

/** Returns highest of two values passed in
 *  @param {Number} valueA
 *  @param {Number} valueB
 *  @return {Number}
 *  @memberof Utilities */
const max = (a, b)=> a > b ?  a : b;

/** Returns the sign of value passed in (also returns 1 if 0)
 *  @param {Number} value
 *  @return {Number}
 *  @memberof Utilities */
const sign = (a)=> a &lt; 0 ? -1 : 1;

/** Returns first parm modulo the second param, but adjusted so negative numbers work as expected
 *  @param {Number} dividend
 *  @param {Number} [divisor=1]
 *  @return {Number}
 *  @memberof Utilities */
const mod = (a, b=1)=> ((a % b) + b) % b;

/** Clamps the value beween max and min
 *  @param {Number} value
 *  @param {Number} [min=0]
 *  @param {Number} [max=1]
 *  @return {Number}
 *  @memberof Utilities */
const clamp = (v, min=0, max=1)=> v &lt; min ? min : v > max ? max : v;

/** Returns what percentage the value is between max and min
 *  @param {Number} value
 *  @param {Number} [min=0]
 *  @param {Number} [max=1]
 *  @return {Number}
 *  @memberof Utilities */
const percent = (v, min=0, max=1)=> max-min ? clamp((v-min) / (max-min)) : 0;

/** Linearly interpolates the percent value between max and min
 *  @param {Number} percent
 *  @param {Number} [min=0]
 *  @param {Number} [max=1]
 *  @return {Number}
 *  @memberof Utilities */
const lerp = (p, min=0, max=1)=> min + clamp(p) * (max-min);

/** Applies smoothstep function to the percentage value
 *  @param {Number} value
 *  @return {Number}
 *  @memberof Utilities */
const smoothStep = (p)=> p * p * (3 - 2 * p);

/** Returns the nearest power of two not less then the value
 *  @param {Number} value
 *  @return {Number}
 *  @memberof Utilities */
const nearestPowerOfTwo = (v)=> 2**Math.ceil(Math.log2(v));

/** Returns true if two axis aligned bounding boxes are overlapping 
 *  @param {Vector2} pointA  - Center of box A
 *  @param {Vector2} sizeA   - Size of box A
 *  @param {Vector2} pointB  - Center of box B
 *  @param {Vector2} [sizeB] - Size of box B
 *  @return {Boolean}        - True if overlapping
 *  @memberof Utilities */
const isOverlapping = (pA, sA, pB, sB)=> abs(pA.x - pB.x)*2 &lt; sA.x + sB.x &amp; abs(pA.y - pB.y)*2 &lt; sA.y + sB.y;

/** Returns an oscillating wave between 0 and amplitude with frequency of 1 Hz by default
 *  @param {Number} [frequency=1] - Frequency of the wave in Hz
 *  @param {Number} [amplitude=1] - Amplitude (max height) of the wave
 *  @param {Number} [t=time]      - Value to use for time of the wave
 *  @return {Number}              - Value waving between 0 and amplitude
 *  @memberof Utilities */
const wave = (frequency=1, amplitude=1, t=time)=> amplitude/2 * (1 - Math.cos(t*frequency*2*PI));

/** Formats seconds to mm:ss style for display purposes 
 *  @param {Number} t - time in seconds
 *  @return {String}
 *  @memberof Utilities */
const formatTime = (t)=> (t/60|0)+':'+(t%60&lt;10?'0':'')+(t%60|0);

///////////////////////////////////////////////////////////////////////////////

/** Random global functions
 *  @namespace Random */

/** Returns a random value between the two values passed in
 *  @param {Number} [valueA=1]
 *  @param {Number} [valueB=0]
 *  @return {Number}
 *  @memberof Random */
const rand = (a=1, b=0)=> b + (a-b)*Math.random();

/** Returns a floored random value the two values passed in
 *  @param {Number} [valueA=1]
 *  @param {Number} [valueB=0]
 *  @return {Number}
 *  @memberof Random */
const randInt = (a=1, b=0)=> rand(a,b)|0;

/** Randomly returns either -1 or 1
 *  @return {Number}
 *  @memberof Random */
const randSign = ()=> (rand(2)|0) * 2 - 1;

/** Returns a random Vector2 within a circular shape
 *  @param {Number} [radius=1]
 *  @param {Number} [minRadius=0]
 *  @return {Vector2}
 *  @memberof Random */
const randInCircle = (radius=1, minRadius=0)=> radius > 0 ? randVector(radius * rand(minRadius / radius, 1)**.5) : new Vector2;

/** Returns a random Vector2 with the passed in length
 *  @param {Number} [length=1]
 *  @return {Vector2}
 *  @memberof Random */
const randVector = (length=1)=> new Vector2().setAngle(rand(2*PI), length);

/** Returns a random color between the two passed in colors, combine components if linear
 *  @param {Color}   [colorA=new Color(1,1,1,1)]
 *  @param {Color}   [colorB=new Color(0,0,0,1)]
 *  @param {Boolean} [linear]
 *  @return {Color}
 *  @memberof Random */
const randColor = (cA = new Color, cB = new Color(0,0,0,1), linear)=>
    linear ? cA.lerp(cB, rand()) : new Color(rand(cA.r,cB.r),rand(cA.g,cB.g),rand(cA.b,cB.b),rand(cA.a,cB.a));

/** The seed used by the randSeeded function, should not be 0
 *  @memberof Random */
let randSeed = 1;

/** Returns a seeded random value between the two values passed in using randSeed
 *  @param {Number} [valueA=1]
 *  @param {Number} [valueB=0]
 *  @return {Number}
 *  @memberof Random */
const randSeeded = (a=1, b=0)=>
{
    randSeed ^= randSeed &lt;&lt; 13; randSeed ^= randSeed >>> 17; randSeed ^= randSeed &lt;&lt; 5; // xorshift
    return b + (a-b) * abs(randSeed % 1e9) / 1e9;
}

///////////////////////////////////////////////////////////////////////////////

/** 
 * Create a 2d vector, can take another Vector2 to copy, 2 scalars, or 1 scalar
 * @param {Number} [x=0]
 * @param {Number} [y=0]
 * @return {Vector2}
 * @example
 * let a = vec2(0, 1); // vector with coordinates (0, 1)
 * let b = vec2(a);    // copy a into b
 * a = vec2(5);        // set a to (5, 5)
 * b = vec2();         // set b to (0, 0)
 * @memberof Utilities
 */
const vec2 = (x=0, y)=> x.x == undefined ? new Vector2(x, y == undefined? x : y) : new Vector2(x.x, x.y);

/** 
 * 2D Vector object with vector math library
 * &lt;br> - Functions do not change this so they can be chained together
 * @example
 * let a = new Vector2(2, 3); // vector with coordinates (2, 3)
 * let b = new Vector2;       // vector with coordinates (0, 0)
 * let c = vec2(4, 2);        // use the vec2 function to make a Vector2
 * let d = a.add(b).scale(5); // operators can be chained
 */
class Vector2
{
    /** Create a 2D vector with the x and y passed in, can also be created with vec2()
     *  @param {Number} [x=0] - X axis location
     *  @param {Number} [y=0] - Y axis location */
    constructor(x=0, y=0)
    {
        /** @property {Number} - X axis location */
        this.x = x;
        /** @property {Number} - Y axis location */
        this.y = y;
    }

    /** Returns a new vector that is a copy of this
     *  @return {Vector2} */
    copy() { return new Vector2(this.x, this.y); }

    /** Returns a copy of this vector plus the vector passed in
     *  @param {Vector2} vector
     *  @return {Vector2} */
    add(v) { ASSERT(v.x!=undefined); return new Vector2(this.x + v.x, this.y + v.y); }

    /** Returns a copy of this vector minus the vector passed in
     *  @param {Vector2} vector
     *  @return {Vector2} */
    subtract(v) { ASSERT(v.x!=undefined); return new Vector2(this.x - v.x, this.y - v.y); }

    /** Returns a copy of this vector times the vector passed in
     *  @param {Vector2} vector
     *  @return {Vector2} */
    multiply(v) { ASSERT(v.x!=undefined); return new Vector2(this.x * v.x, this.y * v.y); }

    /** Returns a copy of this vector divided by the vector passed in
     *  @param {Vector2} vector
     *  @return {Vector2} */
    divide(v) { ASSERT(v.x!=undefined); return new Vector2(this.x / v.x, this.y / v.y); }

    /** Returns a copy of this vector scaled by the vector passed in
     *  @param {Number} scale
     *  @return {Vector2} */
    scale(s) { ASSERT(s.x==undefined); return new Vector2(this.x * s, this.y * s); }

    /** Returns the length of this vector
     * @return {Number} */
    length() { return this.lengthSquared()**.5; }

    /** Returns the length of this vector squared
     * @return {Number} */
    lengthSquared() { return this.x**2 + this.y**2; }

    /** Returns the distance from this vector to vector passed in
     * @param {Vector2} vector
     * @return {Number} */
    distance(v) { return this.distanceSquared(v)**.5; }

    /** Returns the distance squared from this vector to vector passed in
     * @param {Vector2} vector
     * @return {Number} */
    distanceSquared(v) { return (this.x - v.x)**2 + (this.y - v.y)**2; }

    /** Returns a new vector in same direction as this one with the length passed in
     * @param {Number} [length=1]
     * @return {Vector2} */
    normalize(length=1) { const l = this.length(); return l ? this.scale(length/l) : new Vector2(0, length); }

    /** Returns a new vector clamped to length passed in
     * @param {Number} [length=1]
     * @return {Vector2} */
    clampLength(length=1) { const l = this.length(); return l > length ? this.scale(length/l) : this; }

    /** Returns the dot product of this and the vector passed in
     * @param {Vector2} vector
     * @return {Number} */
    dot(v) { ASSERT(v.x!=undefined); return this.x*v.x + this.y*v.y; }

    /** Returns the cross product of this and the vector passed in
     * @param {Vector2} vector
     * @return {Number} */
    cross(v) { ASSERT(v.x!=undefined); return this.x*v.y - this.y*v.x; }

    /** Returns the angle of this vector, up is angle 0
     * @return {Number} */
    angle() { return Math.atan2(this.x, this.y); }

    /** Sets this vector with angle and length passed in
     * @param {Number} [angle=0]
     * @param {Number} [length=1] */
    setAngle(a=0, length=1) { this.x = length*Math.sin(a); this.y = length*Math.cos(a); return this; }

    /** Returns copy of this vector rotated by the angle passed in
     * @param {Number} angle
     * @return {Vector2} */
    rotate(a) { const c = Math.cos(a), s = Math.sin(a); return new Vector2(this.x*c-this.y*s, this.x*s+this.y*c); }

    /** Returns the integer direction of this vector, corrosponding to multiples of 90 degree rotation (0-3)
     * @return {Number} */
    direction() { return abs(this.x) > abs(this.y) ? this.x &lt; 0 ? 3 : 1 : this.y &lt; 0 ? 2 : 0; }

    /** Returns a copy of this vector that has been inverted
     * @return {Vector2} */
    invert() { return new Vector2(this.y, -this.x); }

    /** Returns a copy of this vector with each axis floored
     * @return {Vector2} */
    floor() { return new Vector2(Math.floor(this.x), Math.floor(this.y)); }

    /** Returns the area this vector covers as a rectangle
     * @return {Number} */
    area() { return abs(this.x * this.y); }

    /** Returns a new vector that is p percent between this and the vector passed in
     * @param {Vector2} vector
     * @param {Number}  percent
     * @return {Vector2} */
    lerp(v, p) { ASSERT(v.x!=undefined); return this.add(v.subtract(this).scale(clamp(p))); }

    /** Returns true if this vector is within the bounds of an array size passed in
     * @param {Vector2} arraySize
     * @return {Boolean} */
    arrayCheck(arraySize) { return this.x >= 0 &amp;&amp; this.y >= 0 &amp;&amp; this.x &lt; arraySize.x &amp;&amp; this.y &lt; arraySize.y; }

    /** Returns this vector expressed as a string
     * @param {float} digits - precision to display
     * @return {String} */
    toString(digits=3) 
    { return `(${(this.x&lt;0?'':' ') + this.x.toFixed(digits)},${(this.y&lt;0?'':' ') + this.y.toFixed(digits)} )`; }
}

///////////////////////////////////////////////////////////////////////////////

/** 
 * Create a color object with RGBA values
 * @param {Number} [r=1]
 * @param {Number} [g=1]
 * @param {Number} [b=1]
 * @param {Number} [a=1]
 * @return {Color}
 * @memberof Utilities
 */
const colorRGBA = (r, g, b, a)=> new Color(r, g, b, a);

/** 
 * Create a color object with HSLA values
 * @param {Number} [h=0]
 * @param {Number} [s=0]
 * @param {Number} [l=1]
 * @param {Number} [a=1]
 * @return {Color}
 * @memberof Utilities
 */
const colorHSLA = (h, s, l, a)=> new Color().setHSLA(h, s, l, a);

/** 
 * Color object (red, green, blue, alpha) with some helpful functions
 * @example
 * let a = new Color;             // white
 * let b = new Color(1, 0, 0);    // red
 * let c = new Color(0, 0, 0, 0); // transparent black
 */
class Color
{
    /** Create a color with the components passed in, white by default
     *  @param {Number} [red=1]
     *  @param {Number} [green=1]
     *  @param {Number} [blue=1]
     *  @param {Number} [alpha=1] */
    constructor(r=1, g=1, b=1, a=1)
    {
        /** @property {Number} - Red */
        this.r = r;
        /** @property {Number} - Green */
        this.g = g;
        /** @property {Number} - Blue */
        this.b = b;
        /** @property {Number} - Alpha */
        this.a = a;
    }

    /** Returns a new color that is a copy of this
     * @return {Color} */
    copy() { return new Color(this.r, this.g, this.b, this.a); }

    /** Returns a copy of this color plus the color passed in
     * @param {Color} color
     * @return {Color} */
    add(c) { return new Color(this.r+c.r, this.g+c.g, this.b+c.b, this.a+c.a); }

    /** Returns a copy of this color minus the color passed in
     * @param {Color} color
     * @return {Color} */
    subtract(c) { return new Color(this.r-c.r, this.g-c.g, this.b-c.b, this.a-c.a); }

    /** Returns a copy of this color times the color passed in
     * @param {Color} color
     * @return {Color} */
    multiply(c) { return new Color(this.r*c.r, this.g*c.g, this.b*c.b, this.a*c.a); }

    /** Returns a copy of this color divided by the color passed in
     * @param {Color} color
     * @return {Color} */
    divide(c) { return new Color(this.r/c.r, this.g/c.g, this.b/c.b, this.a/c.a); }

    /** Returns a copy of this color scaled by the value passed in, alpha can be scaled separately
     * @param {Number} scale
     * @param {Number} [alphaScale=scale]
     * @return {Color} */
    scale(s, a=s) { return new Color(this.r*s, this.g*s, this.b*s, this.a*a); }

    /** Returns a copy of this color clamped to the valid range between 0 and 1
     * @return {Color} */
    clamp() { return new Color(clamp(this.r), clamp(this.g), clamp(this.b), clamp(this.a)); }

    /** Returns a new color that is p percent between this and the color passed in
     * @param {Color}  color
     * @param {Number} percent
     * @return {Color} */
    lerp(c, p) { return this.add(c.subtract(this).scale(clamp(p))); }

    /** Sets this color given a hue, saturation, lightness, and alpha
     * @param {Number} [hue=0]
     * @param {Number} [saturation=0]
     * @param {Number} [lightness=1]
     * @param {Number} [alpha=1]
     * @return {Color} */
    setHSLA(h=0, s=0, l=1, a=1)
    {
        const q = l &lt; .5 ? l*(1+s) : l+s-l*s, p = 2*l-q,
            f = (p, q, t)=>
                (t = ((t%1)+1)%1) &lt; 1/6 ? p+(q-p)*6*t :
                t &lt; 1/2 ? q :
                t &lt; 2/3 ? p+(q-p)*(2/3-t)*6 : p;
                
        this.r = f(p, q, h + 1/3);
        this.g = f(p, q, h);
        this.b = f(p, q, h - 1/3);
        this.a = a;
        return this;
    }

    /** Returns this color expressed in hsla format
     * @return {Array} */
    getHSLA()
    {
        const r = clamp(this.r);
        const g = clamp(this.g);
        const b = clamp(this.b);
        const a = clamp(this.a);
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const l = (max + min) / 2;
        
        let h = 0, s = 0;
        if (max != min)
        {
            let d = max - min;
            s = l > .5 ? d / (2 - max - min) : d / (max + min);
            if (r == max)
                h = (g - b) / d + (g &lt; b ? 6 : 0);
            else if (g == max)
                h = (b - r) / d + 2;
            else if (b == max)
                h =  (r - g) / d + 4;
        }

        return [h / 6, s, l, a];
    }

    /** Returns a new color that has each component randomly adjusted
     * @param {Number} [amount=.05]
     * @param {Number} [alphaAmount=0]
     * @return {Color} */
    mutate(amount=.05, alphaAmount=0) 
    {
        return new Color
        (
            this.r + rand(amount, -amount),
            this.g + rand(amount, -amount),
            this.b + rand(amount, -amount),
            this.a + rand(alphaAmount, -alphaAmount)
        ).clamp();
    }

    /** Returns this color expressed as a hex color code
     * @param {Boolean} [useAlpha=1] - if alpha should be included in result
     * @return {String} */
    toString(useAlpha = 1)      
    { 
        const toHex = (c)=> ((c=c*255|0)&lt;16 ? '0' : '') + c.toString(16);
        return '#' + toHex(this.r) + toHex(this.g) + toHex(this.b) + (useAlpha ? toHex(this.a) : '');
    }

    /** Set this color from a hex code
     * @param {String} hex - html hex code
     * @return {Color} */
    setHex(hex)
    {
        const fromHex = (c)=> clamp(parseInt(hex.slice(c,c+2),16)/255);
        this.r = fromHex(1);
        this.g = fromHex(3),
        this.b = fromHex(5);
        this.a = hex.length > 7 ? fromHex(7) : 1;
        return this;
    }
    
    /** Returns this color expressed as 32 bit RGBA value
     * @return {Number} */
    rgbaInt()  
    {
        const toByte = (c)=> clamp(c)*255|0;
        const r = toByte(this.r);
        const g = toByte(this.g)&lt;&lt;8;
        const b = toByte(this.b)&lt;&lt;16;
        const a = toByte(this.a)&lt;&lt;24;
        return r + g + b + a;
    }
}

///////////////////////////////////////////////////////////////////////////////

/**
 * Timer object tracks how long has passed since it was set
 * @example
 * let a = new Timer;    // creates a timer that is not set
 * a.set(3);             // sets the timer to 3 seconds
 *
 * let b = new Timer(1); // creates a timer with 1 second left
 * b.unset();            // unsets the timer
 */
class Timer
{
    /** Create a timer object set time passed in
     *  @param {Number} [timeLeft] - How much time left before the timer elapses in seconds */
    constructor(timeLeft) { this.time = timeLeft == undefined ? undefined : time + timeLeft; this.setTime = timeLeft; }

    /** Set the timer with seconds passed in
     *  @param {Number} [timeLeft=0] - How much time left before the timer is elapsed in seconds */
    set(timeLeft=0) { this.time = time + timeLeft; this.setTime = timeLeft; }

    /** Unset the timer */
    unset() { this.time = undefined; }

    /** Returns true if set
     * @return {Boolean} */
    isSet() { return this.time != undefined; }

    /** Returns true if set and has not elapsed
     * @return {Boolean} */
    active() { return time &lt;= this.time; }

    /** Returns true if set and elapsed
     * @return {Boolean} */
    elapsed() { return time > this.time; }

    /** Get how long since elapsed, returns 0 if not set (returns negative if currently active)
     * @return {Number} */
    get() { return this.isSet()? time - this.time : 0; }

    /** Get percentage elapsed based on time it was set to, returns 0 if not set
     * @return {Number} */
    getPercent() { return this.isSet()? percent(this.time - time, this.setTime, 0) : 0; }
    
    /** Returns this timer expressed as a string
     * @return {String} */
    toString() { if (debug) { return this.unset() ? 'unset' : Math.abs(this.get()) + ' seconds ' + (this.get()&lt;0 ? 'before' : 'after' ); } }
    
    /** Get how long since elapsed, returns 0 if not set (returns negative if currently active)
     * @return {Number} */
    valueOf()               { return this.get(); }
}
/**
 * LittleJS Engine Settings
 * @namespace Settings
 */

'use strict';

///////////////////////////////////////////////////////////////////////////////
// Display settings

/** The max size of the canvas, centered if window is larger
 *  @type {Vector2} 
 *  @default
 *  @memberof Settings */
let canvasMaxSize = vec2(1920, 1200);

/** Fixed size of the canvas, if enabled canvas size never changes
 * - you may also need to set mainCanvasSize if using screen space coords in startup
 *  @type {Vector2} 
 *  @default
 *  @memberof Settings */
let canvasFixedSize = vec2();

/** Disables anti aliasing for pixel art if true
 *  @default
 *  @memberof Settings */
let cavasPixelated = 1;

/** Default font used for text rendering
 *  @default
 *  @memberof Settings */
let fontDefault = 'arial';

///////////////////////////////////////////////////////////////////////////////
// Tile sheet settings

/** Default size of tiles in pixels
 *  @type {Vector2} 
 *  @default
 *  @memberof Settings */
let tileSizeDefault = vec2(16);

/** Prevent tile bleeding from neighbors in pixels
 *  @default
 *  @memberof Settings */
let tileFixBleedScale = .3;

///////////////////////////////////////////////////////////////////////////////
// Object settings

/** Default size of objects
 *  @type {Vector2} 
 *  @default
 *  @memberof Settings */
let objectDefaultSize = vec2(1);

/** Enable physics solver for collisions between objects
 *  @default
 *  @memberof Settings */
let enablePhysicsSolver = 1;

/** Default object mass for collison calcuations (how heavy objects are)
 *  @default
 *  @memberof Settings */
let objectDefaultMass = 1;

/** How much to slow velocity by each frame (0-1)
 *  @default
 *  @memberof Settings */
let objectDefaultDamping = .99;

/** How much to slow angular velocity each frame (0-1)
 *  @default
 *  @memberof Settings */
let objectDefaultAngleDamping = .99;

/** How much to bounce when a collision occurs (0-1)
 *  @default
 *  @memberof Settings */
let objectDefaultElasticity = 0;

/** How much to slow when touching (0-1)
 *  @default
 *  @memberof Settings */
let objectDefaultFriction = .8;

/** Clamp max speed to avoid fast objects missing collisions
 *  @default
 *  @memberof Settings */
let objectMaxSpeed = 1;

/** How much gravity to apply to objects along the Y axis, negative is down
 *  @default
 *  @memberof Settings */
let gravity = 0;

/** Scales emit rate of particles, useful for low graphics mode (0 disables particle emitters)
 *  @default
 *  @memberof Settings */
let particleEmitRateScale = 1;

///////////////////////////////////////////////////////////////////////////////
// Camera settings

/** Position of camera in world space
 *  @type {Vector2}
 *  @default
 *  @memberof Settings */
let cameraPos = vec2();

/** Scale of camera in world space
 *  @default
 *  @memberof Settings */
let cameraScale = max(tileSizeDefault.x, tileSizeDefault.y);

///////////////////////////////////////////////////////////////////////////////
// WebGL settings

/** Enable webgl rendering, webgl can be disabled and removed from build (with some features disabled)
 *  @default
 *  @memberof Settings */
let glEnable = 1;

/** Fixes slow rendering in some browsers by not compositing the WebGL canvas
 *  @default
 *  @memberof Settings */
let glOverlay = 1;

///////////////////////////////////////////////////////////////////////////////
// Input settings

/** Should gamepads be allowed
 *  @default
 *  @memberof Settings */
let gamepadsEnable = 1;

/** If true, the dpad input is also routed to the left analog stick (for better accessability)
 *  @default
 *  @memberof Settings */
let gamepadDirectionEmulateStick = 1;

/** If true the WASD keys are also routed to the direction keys (for better accessability)
 *  @default
 *  @memberof Settings */
let inputWASDEmulateDirection = 1;

/** True if touch gamepad should appear on mobile devices
 *  &lt;br> - Supports left analog stick, 4 face buttons and start button (button 9)
 *  &lt;br> - Must be set by end of gameInit to be activated
 *  @default
 *  @memberof Settings */
let touchGamepadEnable = 0;

/** True if touch gamepad should be analog stick or false to use if 8 way dpad
 *  @default
 *  @memberof Settings */
let touchGamepadAnalog = 1;

/** Size of virutal gamepad for touch devices in pixels
 *  @default
 *  @memberof Settings */
let touchGamepadSize = 80;

/** Transparency of touch gamepad overlay
 *  @default
 *  @memberof Settings */
let touchGamepadAlpha = .3;

/** Allow vibration hardware if it exists
 *  @default
 *  @memberof Settings */
let vibrateEnable = 1;

///////////////////////////////////////////////////////////////////////////////
// Audio settings

/** Volume scale to apply to all sound, music and speech
 *  @default
 *  @memberof Settings */
let soundVolume = .5;

/** All audio code can be disabled and removed from build
 *  @default
 *  @memberof Settings */
let soundEnable = 1;

/** Default range where sound no longer plays
 *  @default
 *  @memberof Settings */
let soundDefaultRange = 30;

/** Default range percent to start tapering off sound (0-1)
 *  @default
 *  @memberof Settings */
let soundDefaultTaper = .7;

///////////////////////////////////////////////////////////////////////////////
// Medals settings

/** How long to show medals for in seconds
 *  @default
 *  @memberof Settings */
let medalDisplayTime = 5;

/** How quickly to slide on/off medals in seconds
 *  @default
 *  @memberof Settings */
let medalDisplaySlideTime = .5;

/** Width of medal display
 *  @default
 *  @memberof Settings */
let medalDisplayWidth = 640;

/** Height of medal display
 *  @default
 *  @memberof Settings */
let medalDisplayHeight = 80;

/** Size of icon in medal display
 *  @default
 *  @memberof Settings */
let medalDisplayIconSize = 50;
/*
    LittleJS Object System
*/

'use strict';

/** 
 * LittleJS Object Base Object Class
 * &lt;br> - Base object class used by the engine
 * &lt;br> - Automatically adds self to object list
 * &lt;br> - Will be updated and rendered each frame
 * &lt;br> - Renders as a sprite from a tilesheet by default
 * &lt;br> - Can have color and addtive color applied
 * &lt;br> - 2d Physics and collision system
 * &lt;br> - Sorted by renderOrder
 * &lt;br> - Objects can have children attached
 * &lt;br> - Parents are updated before children, and set child transform
 * &lt;br> - Call destroy() to get rid of objects
 * &lt;br>
 * &lt;br>The physics system used by objects is simple and fast with some caveats...
 * &lt;br> - Collision uses the axis aligned size, the object's rotation angle is only for rendering
 * &lt;br> - Objects are guaranteed to not intersect tile collision from physics
 * &lt;br> - If an object starts or is moved inside tile collision, it will not collide with that tile
 * &lt;br> - Collision for objects can be set to be solid to block other objects
 * &lt;br> - Objects may get pushed into overlapping other solid objects, if so they will push away
 * &lt;br> - Solid objects are more performance intensive and should be used sparingly
 * @example
 * // create an engine object, normally you would first extend the class with your own
 * const pos = vec2(2,3);
 * const object = new EngineObject(pos); 
 */
class EngineObject
{
    /** Create an engine object and adds it to the list of objects
     *  @param {Vector2} [position=new Vector2()]    - World space position of the object
     *  @param {Vector2} [size=objectDefaultSize]    - World space size of the object
     *  @param {Number}  [tileIndex=-1]              - Tile to use to render object (-1 is untextured)
     *  @param {Vector2} [tileSize=tileSizeDefault]  - Size of tile in source pixels
     *  @param {Number}  [angle=0]                   - Angle the object is rotated by
     *  @param {Color}   [color]                     - Color to apply to tile when rendered
     *  @param {Number}  [renderOrder=0]             - Objects sorted by renderOrder before being rendered
     */
    constructor(pos=vec2(), size=objectDefaultSize, tileIndex=-1, tileSize=tileSizeDefault, angle=0, color, renderOrder=0)
    {
        // set passed in params
        ASSERT(pos &amp;&amp; pos.x != undefined &amp;&amp; size.x != undefined); // ensure pos and size are vec2s

        /** @property {Vector2} - World space position of the object */
        this.pos = pos.copy();
        /** @property {Vector2} - World space width and height of the object */
        this.size = size;
        /** @property {Vector2} - Size of object used for drawing, uses size if not set */
        this.drawSize;
        /** @property {Number}  - Tile to use to render object (-1 is untextured) */
        this.tileIndex = tileIndex;
        /** @property {Vector2} - Size of tile in source pixels */
        this.tileSize = tileSize;
        /** @property {Number}  - Angle to rotate the object */
        this.angle = angle;
        /** @property {Color}   - Color to apply when rendered */
        this.color = color;
        /** @property {Color}   - Additive color to apply when rendered */
        this.additiveColor;

        // set object defaults
        /** @property {Number} [mass=objectDefaultMass]                 - How heavy the object is, static if 0 */
        this.mass         = objectDefaultMass;
        /** @property {Number} [damping=objectDefaultDamping]           - How much to slow down velocity each frame (0-1) */
        this.damping      = objectDefaultDamping;
        /** @property {Number} [angleDamping=objectDefaultAngleDamping] - How much to slow down rotation each frame (0-1) */
        this.angleDamping = objectDefaultAngleDamping;
        /** @property {Number} [elasticity=objectDefaultElasticity]     - How bouncy the object is when colliding (0-1) */
        this.elasticity   = objectDefaultElasticity;
        /** @property {Number} [friction=objectDefaultFriction]         - How much friction to apply when sliding (0-1) */
        this.friction     = objectDefaultFriction;
        /** @property {Number} [gravityScale=1]                         - How much to scale gravity by for this object */
        this.gravityScale = 1;
        /** @property {Number} [renderOrder=0]                          - Objects are sorted by render order */
        this.renderOrder = renderOrder;
        /** @property {Vector2} [velocity=new Vector2()]                - Velocity of the object */
        this.velocity = new Vector2();
        /** @property {Number} [angleVelocity=0]                        - Angular velocity of the object */
        this.angleVelocity = 0;

        // init other internal object stuff
        this.spawnTime = time;
        this.children = [];
        this.collideTiles = 1;

        // add to list of objects
        engineObjects.push(this);
    }
    
    /** Update the object transform and physics, called automatically by engine once each frame */
    update()
    {
        const parent = this.parent;
        if (parent)
        {
            // copy parent pos/angle
            this.pos = this.localPos.multiply(vec2(parent.getMirrorSign(),1)).rotate(-parent.angle).add(parent.pos);
            this.angle = parent.getMirrorSign()*this.localAngle + parent.angle;
            return;
        }

        // limit max speed to prevent missing collisions
        this.velocity.x = clamp(this.velocity.x, -objectMaxSpeed, objectMaxSpeed);
        this.velocity.y = clamp(this.velocity.y, -objectMaxSpeed, objectMaxSpeed);

        // apply physics
        const oldPos = this.pos.copy();
        this.pos.x += this.velocity.x = this.damping * this.velocity.x;
        this.pos.y += this.velocity.y = this.damping * this.velocity.y + gravity * this.gravityScale;
        this.angle += this.angleVelocity *= this.angleDamping;

        // physics sanity checks
        ASSERT(this.angleDamping >= 0 &amp;&amp; this.angleDamping &lt;= 1);
        ASSERT(this.damping >= 0 &amp;&amp; this.damping &lt;= 1);

        if (!enablePhysicsSolver || !this.mass) // do not update collision for fixed objects
            return;

        const wasMovingDown = this.velocity.y &lt; 0;
        if (this.groundObject)
        {
            // apply friction in local space of ground object
            const groundSpeed = this.groundObject.velocity ? this.groundObject.velocity.x : 0;
            this.velocity.x = groundSpeed + (this.velocity.x - groundSpeed) * this.friction;
            this.groundObject = 0;
            //debugOverlay &amp;&amp; debugPhysics &amp;&amp; debugPoint(this.pos.subtract(vec2(0,this.size.y/2)), '#0f0');
        }

        if (this.collideSolidObjects)
        {
            // check collisions against solid objects
            const epsilon = 1e-3; // necessary to push slightly outside of the collision
            for (const o of engineObjectsCollide)
            {
                // non solid objects don't collide with eachother
                if (!this.isSolid &amp; !o.isSolid || o.destroyed || o.parent || o == this)
                    continue;

                // check collision
                if (!isOverlapping(this.pos, this.size, o.pos, o.size))
                    continue;

                // pass collision to objects
                if (!this.collideWithObject(o) | !o.collideWithObject(this))
                    continue;

                if (isOverlapping(oldPos, this.size, o.pos, o.size))
                {
                    // if already was touching, try to push away
                    const deltaPos = oldPos.subtract(o.pos);
                    const length = deltaPos.length();
                    const pushAwayAccel = .001; // push away if already overlapping
                    const velocity = length &lt; .01 ? randVector(pushAwayAccel) : deltaPos.scale(pushAwayAccel/length);
                    this.velocity = this.velocity.add(velocity);
                    if (o.mass) // push away if not fixed
                        o.velocity = o.velocity.subtract(velocity);
                        
                    debugOverlay &amp;&amp; debugPhysics &amp;&amp; debugAABB(this.pos, this.size, o.pos, o.size, '#f00');
                    continue;
                }

                // check for collision
                const sizeBoth = this.size.add(o.size);
                const smallStepUp = (oldPos.y - o.pos.y)*2 > sizeBoth.y + gravity; // prefer to push up if small delta
                const isBlockedX = abs(oldPos.y - o.pos.y)*2 &lt; sizeBoth.y;
                const isBlockedY = abs(oldPos.x - o.pos.x)*2 &lt; sizeBoth.x;
                
                if (smallStepUp || isBlockedY || !isBlockedX) // resolve y collision
                {
                    // push outside object collision
                    this.pos.y = o.pos.y + (sizeBoth.y/2 + epsilon) * sign(oldPos.y - o.pos.y);
                    if (o.groundObject &amp;&amp; wasMovingDown || !o.mass)
                    {
                        // set ground object if landed on something
                        if (wasMovingDown)
                            this.groundObject = o;

                        // bounce if other object is fixed or grounded
                        this.velocity.y *= -this.elasticity;
                    }
                    else if (o.mass)
                    {
                        // inelastic collision
                        const inelastic = (this.mass * this.velocity.y + o.mass * o.velocity.y) / (this.mass + o.mass);

                        // elastic collision
                        const elastic0 = this.velocity.y * (this.mass - o.mass) / (this.mass + o.mass)
                            + o.velocity.y * 2 * o.mass / (this.mass + o.mass);
                        const elastic1 = o.velocity.y * (o.mass - this.mass) / (this.mass + o.mass)
                            + this.velocity.y * 2 * this.mass / (this.mass + o.mass);

                        // lerp betwen elastic or inelastic based on elasticity
                        const elasticity = max(this.elasticity, o.elasticity);
                        this.velocity.y = lerp(elasticity, inelastic, elastic0);
                        o.velocity.y = lerp(elasticity, inelastic, elastic1);
                    }
                }
                if (!smallStepUp &amp;&amp; (isBlockedX || !isBlockedY)) // resolve x collision
                {
                    // push outside collision
                    this.pos.x = o.pos.x + (sizeBoth.x/2 + epsilon) * sign(oldPos.x - o.pos.x);
                    if (o.mass)
                    {
                        // inelastic collision
                        const inelastic = (this.mass * this.velocity.x + o.mass * o.velocity.x) / (this.mass + o.mass);

                        // elastic collision
                        const elastic0 = this.velocity.x * (this.mass - o.mass) / (this.mass + o.mass)
                            + o.velocity.x * 2 * o.mass / (this.mass + o.mass);
                        const elastic1 = o.velocity.x * (o.mass - this.mass) / (this.mass + o.mass)
                            + this.velocity.x * 2 * this.mass / (this.mass + o.mass);

                        // lerp betwen elastic or inelastic based on elasticity
                        const elasticity = max(this.elasticity, o.elasticity);
                        this.velocity.x = lerp(elasticity, inelastic, elastic0);
                        o.velocity.x = lerp(elasticity, inelastic, elastic1);
                    }
                    else // bounce if other object is fixed
                        this.velocity.x *= -this.elasticity;
                }
                debugOverlay &amp;&amp; debugPhysics &amp;&amp; debugAABB(this.pos, this.size, o.pos, o.size, '#f0f');
            }
        }
        if (this.collideTiles)
        {
            // check collision against tiles
            if (tileCollisionTest(this.pos, this.size, this))
            {
                // if already was stuck in collision, don't do anything
                // this should not happen unless something starts in collision
                if (!tileCollisionTest(oldPos, this.size, this))
                {
                    // test which side we bounced off (or both if a corner)
                    const isBlockedY = tileCollisionTest(new Vector2(oldPos.x, this.pos.y), this.size, this);
                    const isBlockedX = tileCollisionTest(new Vector2(this.pos.x, oldPos.y), this.size, this);
                    if (isBlockedY || !isBlockedX)
                    {
                        // set if landed on ground
                        this.groundObject = wasMovingDown;

                        // bounce velocity
                        this.velocity.y *= -this.elasticity;

                        // adjust next velocity to settle on ground
                        const o = (oldPos.y - this.size.y/2|0) - (oldPos.y - this.size.y/2);
                        if (o &lt; 0 &amp;&amp; o > this.damping * this.velocity.y + gravity * this.gravityScale) 
                            this.velocity.y = this.damping ? (o - gravity * this.gravityScale) / this.damping : 0;

                        // move to previous position
                        this.pos.y = oldPos.y;
                    }
                    if (isBlockedX)
                    {
                        // move to previous position and bounce
                        this.pos.x = oldPos.x;
                        this.velocity.x *= -this.elasticity;
                    }
                }
            }
        }
    }
       
    /** Render the object, draws a tile by default, automatically called each frame, sorted by renderOrder */
    render()
    {
        // default object render
        drawTile(this.pos, this.drawSize || this.size, this.tileIndex, this.tileSize, this.color, this.angle, this.mirror, this.additiveColor);
    }
    
    /** Destroy this object, destroy it's children, detach it's parent, and mark it for removal */
    destroy()             
    { 
        if (this.destroyed)
            return;
        
        // disconnect from parent and destroy chidren
        this.destroyed = 1;
        this.parent &amp;&amp; this.parent.removeChild(this);
        for (const child of this.children)
            child.destroy(child.parent = 0);
    }
    
    /** Called to check if a tile collision should be resolved
     *  @param {Number}  tileData - the value of the tile at the position
     *  @param {Vector2} pos      - tile where the collision occured
     *  @return {Boolean}         - true if the collision should be resolved */
    collideWithTile(tileData, pos)        { return tileData > 0; }
    
    /** Called to check if a tile raycast hit
     *  @param {Number}  tileData - the value of the tile at the position
     *  @param {Vector2} pos      - tile where the raycast is
     *  @return {Boolean}         - true if the raycast should hit */
    collideWithTileRaycast(tileData, pos) { return tileData > 0; }

    /** Called to check if a object collision should be resolved
     *  @param {EngineObject} object - the object to test against
     *  @return {Boolean}            - true if the collision should be resolved
     */
    collideWithObject(o)              { return 1; }

    /** How long since the object was created
     *  @return {Number} */
    getAliveTime()                    { return time - this.spawnTime; }

    /** Apply acceleration to this object (adjust velocity, not affected by mass)
     *  @param {Vector2} acceleration */
    applyAcceleration(a)              { if (this.mass) this.velocity = this.velocity.add(a); }

    /** Apply force to this object (adjust velocity, affected by mass)
     *  @param {Vector2} force */
    applyForce(force)	              { this.applyAcceleration(force.scale(1/this.mass)); }
    
    /** Get the direction of the mirror
     *  @return {Number} -1 if this.mirror is true, or 1 if not mirrored */
    getMirrorSign() { return this.mirror ? -1 : 1; }

    /** Attaches a child to this with a given local transform
     *  @param {EngineObject} child
     *  @param {Vector2}      [localPos=new Vector2]
     *  @param {Number}       [localAngle=0] */
    addChild(child, localPos=vec2(), localAngle=0)
    {
        ASSERT(!child.parent &amp;&amp; !this.children.includes(child));
        this.children.push(child);
        child.parent = this;
        child.localPos = localPos.copy();
        child.localAngle = localAngle;
    }

    /** Removes a child from this one
     *  @param {EngineObject} child */
    removeChild(child)
    {
        ASSERT(child.parent == this &amp;&amp; this.children.includes(child));
        this.children.splice(this.children.indexOf(child), 1);
        child.parent = 0;
    }

    /** Set how this object collides
     *  @param {boolean} [collideSolidObjects=1] - Does it collide with solid objects
     *  @param {boolean} [isSolid=1]             - Does it collide with and block other objects (expensive in large numbers)
     *  @param {boolean} [collideTiles=1]        - Does it collide with the tile collision */
    setCollision(collideSolidObjects=1, isSolid=1, collideTiles=1)
    {
        ASSERT(collideSolidObjects || !isSolid); // solid objects must be set to collide

        this.collideSolidObjects = collideSolidObjects;
        this.isSolid = isSolid;
        this.collideTiles = collideTiles;
    }

    toString()
    {
        if (debug)
        {
            let text = 'type = ' + this.constructor.name;
            if (this.pos.x || this.pos.y)
                text += '\npos = ' + this.pos;
            if (this.velocity.x || this.velocity.y)
                text += '\nvelocity = ' + this.velocity;
            if (this.size.x || this.size.y)
                text += '\nsize = ' + this.size;
            if (this.angle)
                text += '\nangle = ' + this.angle.toFixed(3);
            if (this.color)
                text += '\ncolor = ' + this.color;
            return text;
        }
    }
}
/** 
 * LittleJS Drawing System
 * &lt;br> - Hybrid with both Canvas2D and WebGL available
 * &lt;br> - Super fast tile sheet rendering with WebGL
 * &lt;br> - Can apply rotation, mirror, color and additive color
 * &lt;br> - Many useful utility functions
 * &lt;br>
 * &lt;br>LittleJS uses a hybrid rendering solution with the best of both Canvas2D and WebGL.
 * &lt;br>There are 3 canvas/contexts available to draw to...
 * &lt;br> - mainCanvas - 2D background canvas, non WebGL stuff like tile layers are drawn here.
 * &lt;br> - glCanvas - Used by the accelerated WebGL batch rendering system.
 * &lt;br> - overlayCanvas - Another 2D canvas that appears on top of the other 2 canvases.
 * &lt;br>
 * &lt;br>The WebGL rendering system is very fast with some caveats...
 * &lt;br> - The default setup supports only 1 tile sheet, to support more call glCreateTexture and glSetTexture
 * &lt;br> - Switching blend modes (additive) or textures causes another draw call which is expensive in excess
 * &lt;br> - Group additive rendering together using renderOrder to mitigate this issue
 * &lt;br>
 * &lt;br>The LittleJS rendering solution is intentionally simple, feel free to adjust it for your needs!
 * @namespace Draw
 */

'use strict';

/** Tile sheet for batch rendering system
 *  @type {Image}
 *  @memberof Draw */
const tileImage = new Image();

/** The primary 2D canvas visible to the user
 *  @type {HTMLCanvasElement}
 *  @memberof Draw */
let mainCanvas;

/** 2d context for mainCanvas
 *  @type {CanvasRenderingContext2D}
 *  @memberof Draw */
let mainContext;

/** A canvas that appears on top of everything the same size as mainCanvas
 *  @type {HTMLCanvasElement}
 *  @memberof Draw */
let overlayCanvas;

/** 2d context for overlayCanvas
 *  @type {CanvasRenderingContext2D}
 *  @memberof Draw */
let overlayContext;

/** The size of the main canvas (and other secondary canvases) 
 *  @type {Vector2}
 *  @memberof Draw */
let mainCanvasSize = vec2();

/** Convert from screen to world space coordinates
 *  - if calling outside of render, you may need to manually set mainCanvasSize
 *  @param {Vector2} screenPos
 *  @return {Vector2}
 *  @memberof Draw */
const screenToWorld = (screenPos)=>
{
    ASSERT(mainCanvasSize.x &amp;&amp; mainCanvasSize.y, 'mainCanvasSize is invalid');
    return screenPos.add(vec2(.5)).subtract(mainCanvasSize.scale(.5)).multiply(vec2(1/cameraScale,-1/cameraScale)).add(cameraPos);
}

/** Convert from world to screen space coordinates
 *  - if calling outside of render, you may need to manually set mainCanvasSize
 *  @param {Vector2} worldPos
 *  @return {Vector2}
 *  @memberof Draw */
const worldToScreen = (worldPos)=>
{
    ASSERT(mainCanvasSize.x &amp;&amp; mainCanvasSize.y, 'mainCanvasSize is invalid');
    return worldPos.subtract(cameraPos).multiply(vec2(cameraScale,-cameraScale)).add(mainCanvasSize.scale(.5)).subtract(vec2(.5));
}

/** Draw textured tile centered in world space, with color applied if using WebGL
 *  @param {Vector2} pos                                - Center of the tile in world space
 *  @param {Vector2} [size=new Vector2(1,1)]            - Size of the tile in world space, width and height
 *  @param {Number}  [tileIndex=-1]                     - Tile index to use, negative is untextured
 *  @param {Vector2} [tileSize=tileSizeDefault]         - Tile size in source pixels
 *  @param {Color}   [color=new Color(1,1,1)]           - Color to modulate with
 *  @param {Number}  [angle=0]                          - Angle to rotate by
 *  @param {Boolean} [mirror=0]                         - If true image is flipped along the Y axis
 *  @param {Color}   [additiveColor=new Color(0,0,0,0)] - Additive color to be applied
 *  @param {Boolean} [useWebGL=glEnable]                - Use accelerated WebGL rendering
 *  @memberof Draw */
function drawTile(pos, size=vec2(1), tileIndex=-1, tileSize=tileSizeDefault, color=new Color, angle=0, mirror, 
    additiveColor=new Color(0,0,0,0), useWebGL=glEnable)
{
    showWatermark &amp;&amp; ++drawCount;
    if (glEnable &amp;&amp; useWebGL)
    {
        if (tileIndex &lt; 0 || !tileImage.width)
        {
            // if negative tile index or image not found, force untextured
            glDraw(pos.x, pos.y, size.x, size.y, angle, 0, 0, 0, 0, 0, color.rgbaInt()); 
        }
        else
        {
            // calculate uvs and render
            const cols = tileImageSize.x / tileSize.x |0;
            const uvSizeX = tileSize.x / tileImageSize.x;
            const uvSizeY = tileSize.y / tileImageSize.y;
            const uvX = (tileIndex%cols)*uvSizeX, uvY = (tileIndex/cols|0)*uvSizeY;
            
            glDraw(pos.x, pos.y, mirror ? -size.x : size.x, size.y, angle, 
                uvX + tileImageFixBleed.x, uvY + tileImageFixBleed.y, 
                uvX - tileImageFixBleed.x + uvSizeX, uvY - tileImageFixBleed.y + uvSizeY, 
                color.rgbaInt(), additiveColor.rgbaInt()); 
        }
    }
    else
    {
        // normal canvas 2D rendering method (slower)
        drawCanvas2D(pos, size, angle, mirror, (context)=>
        {
            if (tileIndex &lt; 0)
            {
                // if negative tile index, force untextured
                context.fillStyle = color;
                context.fillRect(-.5, -.5, 1, 1);
            }
            else
            {
                // calculate uvs and render
                const cols = tileImageSize.x / tileSize.x |0;
                const sX = (tileIndex%cols)*tileSize.x   + tileFixBleedScale;
                const sY = (tileIndex/cols|0)*tileSize.y + tileFixBleedScale;
                const sWidth  = tileSize.x - 2*tileFixBleedScale;
                const sHeight = tileSize.y - 2*tileFixBleedScale;
                context.globalAlpha = color.a; // only alpha is supported
                context.drawImage(tileImage, sX, sY, sWidth, sHeight, -.5, -.5, 1, 1);
            }
        });
    }
}

/** Draw colored rect centered on pos
 *  @param {Vector2} pos
 *  @param {Vector2} [size=new Vector2(1,1)]
 *  @param {Color}   [color=new Color(1,1,1)]
 *  @param {Number}  [angle=0]
 *  @param {Boolean} [useWebGL=glEnable]
 *  @memberof Draw */
function drawRect(pos, size, color, angle, useWebGL)
{
    drawTile(pos, size, -1, tileSizeDefault, color, angle, 0, 0, useWebGL);
}

/** Draw textured tile centered on pos in screen space
 *  @param {Vector2} pos                        - Center of the tile
 *  @param {Vector2} [size=new Vector2(1,1)]    - Size of the tile
 *  @param {Number}  [tileIndex=-1]             - Tile index to use, negative is untextured
 *  @param {Vector2} [tileSize=tileSizeDefault] - Tile size in source pixels
 *  @param {Color}   [color=new Color]
 *  @param {Number}  [angle=0]
 *  @param {Boolean} [mirror=0]
 *  @param {Color}   [additiveColor=new Color(0,0,0,0)]
 *  @param {Boolean} [useWebGL=glEnable]
 *  @memberof Draw */
function drawTileScreenSpace(pos, size=vec2(1), tileIndex, tileSize, color, angle, mirror, additiveColor, useWebGL)
{
    drawTile(screenToWorld(pos), size.scale(1/cameraScale), tileIndex, tileSize, color, angle, mirror, additiveColor, useWebGL);
}

/** Draw colored rectangle in screen space
 *  @param {Vector2} pos
 *  @param {Vector2} [size=new Vector2(1,1)]
 *  @param {Color}   [color=new Color(1,1,1)]
 *  @param {Number}  [angle=0]
 *  @param {Boolean} [useWebGL=glEnable]
 *  @memberof Draw */
function drawRectScreenSpace(pos, size, color, angle, useWebGL)
{
    drawTileScreenSpace(pos, size, -1, tileSizeDefault, color, angle, 0, 0, useWebGL);
}

/** Draw colored line between two points
 *  @param {Vector2} posA
 *  @param {Vector2} posB
 *  @param {Number}  [thickness=.1]
 *  @param {Color}   [color=new Color(1,1,1)]
 *  @param {Boolean} [useWebGL=glEnable]
 *  @memberof Draw */
function drawLine(posA, posB, thickness=.1, color, useWebGL)
{
    const halfDelta = vec2((posB.x - posA.x)/2, (posB.y - posA.y)/2);
    const size = vec2(thickness, halfDelta.length()*2);
    drawRect(posA.add(halfDelta), size, color, halfDelta.angle(), useWebGL);
}

/** Draw directly to a 2d canvas context in world space
 *  @param {Vector2}  pos
 *  @param {Vector2}  size
 *  @param {Number}   angle
 *  @param {Boolean}  mirror
 *  @param {Function} drawFunction
 *  @param {CanvasRenderingContext2D} [context=mainContext]
 *  @memberof Draw */
function drawCanvas2D(pos, size, angle, mirror, drawFunction, context = mainContext)
{
    // create canvas transform from world space to screen space
    pos = worldToScreen(pos);
    size = size.scale(cameraScale);
    context.save();
    context.translate(pos.x+.5|0, pos.y+.5|0);
    context.rotate(angle);
    context.scale(mirror ? -size.x : size.x, size.y);
    drawFunction(context);
    context.restore();
}

/** Enable normal or additive blend mode
 *  @param {Boolean} [additive=0]
 *  @param {Boolean} [useWebGL=glEnable]
 *  @memberof Draw */
function setBlendMode(additive, useWebGL=glEnable)
{
    if (glEnable &amp;&amp; useWebGL)
        glSetBlendMode(additive);
    else
        mainContext.globalCompositeOperation = additive ? 'lighter' : 'source-over';
}

/** Draw text on overlay canvas in screen space
 *  Automatically splits new lines into rows
 *  @param {String}  text
 *  @param {Vector2} pos
 *  @param {Number}  [size=1]
 *  @param {Color}   [color=new Color(1,1,1)]
 *  @param {Number}  [lineWidth=0]
 *  @param {Color}   [lineColor=new Color(0,0,0)]
 *  @param {String}  [textAlign='center']
 *  @memberof Draw */
function drawTextScreen(text, pos, size=1, color=new Color, lineWidth=0, lineColor=new Color(0,0,0), textAlign='center', font=fontDefault, context=overlayContext)
{
    context.fillStyle = color;
    context.lineWidth = lineWidth;
    context.strokeStyle = lineColor;
    context.textAlign = textAlign;
    context.font = size + 'px '+ font;
    context.textBaseline = 'middle';
    context.lineJoin = 'round';

    pos = pos.copy();
    (text+'').split('\n').forEach(line=>
    {
        lineWidth &amp;&amp; context.strokeText(line, pos.x, pos.y);
        context.fillText(line, pos.x, pos.y);
        pos.y += size;
    });
}

/** Draw text on overlay canvas in world space
 *  Automatically splits new lines into rows
 *  @param {String}  text
 *  @param {Vector2} pos
 *  @param {Number}  [size=1]
 *  @param {Color}   [color=new Color(1,1,1)]
 *  @param {Number}  [lineWidth=0]
 *  @param {Color}   [lineColor=new Color(0,0,0)]
 *  @param {String}  [textAlign='center']
 *  @memberof Draw */
function drawText(text, pos, size=1, color, lineWidth, lineColor, textAlign, font)
{
    drawTextScreen(text, worldToScreen(pos), size*cameraScale, color, lineWidth*cameraScale, lineColor, textAlign, font, mainContext);
}

///////////////////////////////////////////////////////////////////////////////

/** 
 * Font Image Object - Draw text on a 2D canvas by using characters in an image
 * &lt;br> - 96 characters (from space to tilde) are stored in an image
 * &lt;br> - Uses a default 8x8 font if none is supplied
 * &lt;br> - You can also use fonts from the main tile sheet
 * @example
 * // use built in font
 * const font = new ImageFont;
 * 
 * // draw text
 * font.drawTextScreen("LittleJS\nHello World!", vec2(200, 50));
 */

let engineFontImage;

class FontImage
{
    /** Create an image font
     *  @param {HTMLImageElement}   [image] - The image the font is stored in, if undefined the default font is used
     *  @param {Vector2} [tileSize=vec2(8)] - The size of the font source tiles
     *  @param {Vector2} [paddingSize=vec2(0,1)] - How much extra space to add between characters
     *  @param {Number}  [startTileIndex=0] - Tile index in image where font starts
     *  @param {CanvasRenderingContext2D} [context=overlayContext] - context to draw to
     */
    constructor(image, tileSize=vec2(8), paddingSize=vec2(0,1), startTileIndex=0, context=overlayContext)
    {
        if (!image &amp;&amp; !engineFontImage)
        {
            // load default font image
            engineFontImage = new Image();
            engineFontImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAYAQAAAAA9+x6JAAAAAnRSTlMAAHaTzTgAAAGiSURBVHjaZZABhxxBEIUf6ECLBdFY+Q0PMNgf0yCgsSAGZcT9sgIPtBWwIA5wgAPEoHUyJeeSlW+gjK+fegWwtROWpVQEyWh2npdpBmTUFVhb29RINgLIukoXr5LIAvYQ5ve+1FqWEMqNKTX3FAJHyQDRZvmKWubAACcv5z5Gtg2oyCWE+Yk/8JZQX1jTTCpKAFGIgza+dJCNBF2UskRlsgwitHbSV0QLgt9sTPtsRlvJjEr8C/FARWA2bJ/TtJ7lko34dNDn6usJUMzuErP89UUBJbWeozrwLLncXczd508deAjLWipLO4Q5XGPcJvPu92cNDaN0P5G1FL0nSOzddZOrJ6rNhbXGmeDvO3TF7DeJWl4bvaYQTNHCTeuqKZmbjHaSOFes+IX/+IhHrnAkXOAsfn24EM68XieIECoccD4KZLk/odiwzeo2rovYdhvb2HYFgyznJyDpYJdYOmfXgVdJTaUi4xA2uWYNYec9BLeqdl9EsoTw582mSFDX2DxVLbNt9U3YYoeatBad1c2Tj8t2akrjaIGJNywKB/7h75/gN3vCMSaadIUTAAAAAElFTkSuQmCC';
        }

        this.image = image || engineFontImage;
        this.tileSize = tileSize;
        this.paddingSize = paddingSize;
        this.startTileIndex = startTileIndex;
        this.context = context;
    }

    /** Draw text in screen space using the image font
     *  @param {String}  text
     *  @param {Vector2} pos
     *  @param {Number}  [scale=4]
     *  @param {Boolean} [center]
     */
    drawTextScreen(text, pos, scale=4, center)
    {
        const context = this.context;
        context.save();
        context.imageSmoothingEnabled = !cavasPixelated;

        const size = this.tileSize;
        const drawSize = size.add(this.paddingSize).scale(scale);
        const cols = this.image.width / this.tileSize.x |0;
        (text+'').split('\n').forEach((line, i)=>
        {
            const centerOffset = center ? line.length * size.x * scale / 2 |0 : 0;
            for(let j=line.length; j--;)
            {
                // draw each character
                let charCode = line[j].charCodeAt();
                if (charCode &lt; 32 || charCode > 127)
                    charCode = 127; // unknown character

                // get the character source location and draw it
                const tile = this.startTileIndex + charCode - 32;
                const x = tile % cols;
                const y = tile / cols |0;
                const drawPos = pos.add(vec2(j,i).multiply(drawSize));
                context.drawImage(this.image, x * size.x, y * size.y, size.x, size.y, 
                    drawPos.x - centerOffset, drawPos.y, size.x * scale, size.y * scale);
            }
        });

        context.restore();
    }

    /** Draw text in world space using the image font
     *  @param {String}  text
     *  @param {Vector2} pos
     *  @param {Number}  [scale=.25]
     *  @param {Boolean} [center]
     */
    drawText(text, pos, scale=1, center)
    {
        this.drawTextScreen(text, worldToScreen(pos).floor(), scale*cameraScale|0, center);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Fullscreen mode

/** Returns true if fullscreen mode is active
 *  @return {Boolean}
 *  @memberof Draw */
const isFullscreen =()=> document.fullscreenElement;

/** Toggle fullsceen mode
 *  @memberof Draw */
function toggleFullscreen()
{
    if (isFullscreen())
    {
        if (document.exitFullscreen)
            document.exitFullscreen();
        else if (document.mozCancelFullScreen)
            document.mozCancelFullScreen();
    }
    else
    {
        if (document.body.webkitRequestFullScreen)
            document.body.webkitRequestFullScreen();
        else if (document.body.mozRequestFullScreen)
            document.body.mozRequestFullScreen();
    }
}

/** 
 * LittleJS Input System
 * &lt;br> - Tracks key down, pressed, and released
 * &lt;br> - Also tracks mouse buttons, position, and wheel
 * &lt;br> - Supports multiple gamepads
 * &lt;br> - Virtual gamepad for touch devices with touchGamepadSize
 * @namespace Input
 */

'use strict';

/** Returns true if device key is down
 *  @param {Number} key
 *  @param {Number} [device=0]
 *  @return {Boolean}
 *  @memberof Input */
const keyIsDown = (key, device=0)=> inputData[device] &amp;&amp; inputData[device][key] &amp; 1 ? 1 : 0;

/** Returns true if device key was pressed this frame
 *  @param {Number} key
 *  @param {Number} [device=0]
 *  @return {Boolean}
 *  @memberof Input */
const keyWasPressed = (key, device=0)=> inputData[device] &amp;&amp; inputData[device][key] &amp; 2 ? 1 : 0;

/** Returns true if device key was released this frame
 *  @param {Number} key
 *  @param {Number} [device=0]
 *  @return {Boolean}
 *  @memberof Input */
const keyWasReleased = (key, device=0)=> inputData[device] &amp;&amp; inputData[device][key] &amp; 4 ? 1 : 0;

/** Clears all input
 *  @memberof Input */
const clearInput = ()=> inputData = [[]];

/** Returns true if mouse button is down
 *  @param {Number} button
 *  @return {Boolean}
 *  @memberof Input */
const mouseIsDown = keyIsDown;

/** Returns true if mouse button was pressed
 *  @param {Number} button
 *  @return {Boolean}
 *  @memberof Input */
const mouseWasPressed = keyWasPressed;

/** Returns true if mouse button was released
 *  @param {Number} button
 *  @return {Boolean}
 *  @memberof Input */
const mouseWasReleased = keyWasReleased;

/** Mouse pos in world space
 *  @type {Vector2}
 *  @memberof Input */
let mousePos = vec2();

/** Mouse pos in screen space
 *  @type {Vector2}
 *  @memberof Input */
let mousePosScreen = vec2();

/** Mouse wheel delta this frame
 *  @memberof Input */
let mouseWheel = 0;

/** Returns true if user is using gamepad (has more recently pressed a gamepad button)
 *  @memberof Input */
let isUsingGamepad = 0;

/** Prevents input continuing to the default browser handling (false by default)
 *  @memberof Input */
let preventDefaultInput = 0;

/** Returns true if gamepad button is down
 *  @param {Number} button
 *  @param {Number} [gamepad=0]
 *  @return {Boolean}
 *  @memberof Input */
const gamepadIsDown = (button, gamepad=0)=> keyIsDown(button, gamepad+1);

/** Returns true if gamepad button was pressed
 *  @param {Number} button
 *  @param {Number} [gamepad=0]
 *  @return {Boolean}
 *  @memberof Input */
const gamepadWasPressed = (button, gamepad=0)=> keyWasPressed(button, gamepad+1);

/** Returns true if gamepad button was released
 *  @param {Number} button
 *  @param {Number} [gamepad=0]
 *  @return {Boolean}
 *  @memberof Input */
const gamepadWasReleased = (button, gamepad=0)=> keyWasReleased(button, gamepad+1);

/** Returns gamepad stick value
 *  @param {Number} stick
 *  @param {Number} [gamepad=0]
 *  @return {Vector2}
 *  @memberof Input */
const gamepadStick = (stick,  gamepad=0)=> stickData[gamepad] ? stickData[gamepad][stick] || vec2() : vec2();

///////////////////////////////////////////////////////////////////////////////
// Input update called by engine

// store input as a bit field for each key: 1 = isDown, 2 = wasPressed, 4 = wasReleased
// mouse and keyboard are stored together in device 0, gamepads are in devices > 0
let inputData = [[]];

function inputUpdate()
{
    // clear input when lost focus (prevent stuck keys)
    isTouchDevice || document.hasFocus() || clearInput();

    // update mouse world space position
    mousePos = screenToWorld(mousePosScreen);

    // update gamepads if enabled
    gamepadsUpdate();
}

function inputUpdatePost()
{
    // clear input to prepare for next frame
    for (const deviceInputData of inputData)
    for (const i in deviceInputData)
        deviceInputData[i] &amp;= 1;
    mouseWheel = 0;
}

///////////////////////////////////////////////////////////////////////////////
// Keyboard event handlers

onkeydown = (e)=>
{
    if (debug &amp;&amp; e.target != document.body) return;
    e.repeat || (inputData[isUsingGamepad = 0][remapKeyCode(e.keyCode)] = 3);
    preventDefaultInput &amp;&amp; e.preventDefault();
}
onkeyup = (e)=>
{
    if (debug &amp;&amp; e.target != document.body) return;
    inputData[0][remapKeyCode(e.keyCode)] = 4;
}
const remapKeyCode = (c)=> inputWASDEmulateDirection ? c==87?38 : c==83?40 : c==65?37 : c==68?39 : c : c;

///////////////////////////////////////////////////////////////////////////////
// Mouse event handlers

onmousedown = (e)=> {inputData[isUsingGamepad = 0][e.button] = 3; onmousemove(e); e.button &amp;&amp; e.preventDefault();}
onmouseup   = (e)=> inputData[0][e.button] = inputData[0][e.button] &amp; 2 | 4;
onmousemove = (e)=> mousePosScreen = mouseToScreen(e);
onwheel = (e)=> e.ctrlKey || (mouseWheel = sign(e.deltaY));
oncontextmenu = (e)=> !1; // prevent right click menu

// convert a mouse or touch event position to screen space
const mouseToScreen = (mousePos)=>
{
    if (!mainCanvas)
        return vec2(); // fix bug that can occur if user clicks before page loads

    const rect = mainCanvas.getBoundingClientRect();
    return vec2(mainCanvas.width, mainCanvas.height).multiply(
        vec2(percent(mousePos.x, rect.left, rect.right), percent(mousePos.y, rect.top, rect.bottom)));
}

///////////////////////////////////////////////////////////////////////////////
// Gamepad input

const stickData = [];
function gamepadsUpdate()
{
    if (touchGamepadEnable &amp;&amp; touchGamepadTimer.isSet())
    {
        // read virtual analog stick
        const sticks = stickData[0] || (stickData[0] = []);
        sticks[0] = vec2(touchGamepadStick.x, -touchGamepadStick.y); // flip vertical

        // read virtual gamepad buttons
        const data = inputData[1] || (inputData[1] = []);
        for (let i=10; i--;)
        {
            const j = i == 3 ? 2 : i == 2 ? 3 : i; // fix button locations
            data[j] = touchGamepadButtons[i] ? 1 + 2*!gamepadIsDown(j,0) : 4*gamepadIsDown(j,0);
        }
    }

    if (!gamepadsEnable || !navigator || !navigator.getGamepads || !document.hasFocus() &amp;&amp; !debug)
        return;

    // poll gamepads
    const gamepads = navigator.getGamepads();
    for (let i = gamepads.length; i--;)
    {
        // get or create gamepad data
        const gamepad = gamepads[i];
        const data = inputData[i+1] || (inputData[i+1] = []);
        const sticks = stickData[i] || (stickData[i] = []);

        if (gamepad)
        {
            // read clamp dead zone of analog sticks
            const deadZone = .3, deadZoneMax = .8;
            const applyDeadZone = (v)=> 
                v >  deadZone ?  percent( v, deadZone, deadZoneMax) : 
                v &lt; -deadZone ? -percent(-v, deadZone, deadZoneMax) : 0;

            // read analog sticks
            for (let j = 0; j &lt; gamepad.axes.length-1; j+=2)
                sticks[j>>1] = vec2(applyDeadZone(gamepad.axes[j]), applyDeadZone(-gamepad.axes[j+1])).clampLength();
            
            // read buttons
            for (let j = gamepad.buttons.length; j--;)
            {
                const button = gamepad.buttons[j];
                data[j] = button.pressed ? 1 + 2*!gamepadIsDown(j,i) : 4*gamepadIsDown(j,i);
                isUsingGamepad |= !i &amp;&amp; button.pressed;
                touchGamepadEnable &amp;&amp; touchGamepadTimer.unset(); // disable touch gamepad if using real gamepad
            }

            if (gamepadDirectionEmulateStick)
            {
                // copy dpad to left analog stick when pressed
                const dpad = vec2(gamepadIsDown(15,i) - gamepadIsDown(14,i), gamepadIsDown(12,i) - gamepadIsDown(13,i));
                if (dpad.lengthSquared())
                    sticks[0] = dpad.clampLength();
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////

/** Pulse the vibration hardware if it exists
 *  @param {Number} [pattern=100] - a single value in miliseconds or vibration interval array
 *  @memberof Input */
const vibrate = (pattern)=> vibrateEnable &amp;&amp; navigator &amp;&amp; navigator.vibrate &amp;&amp; navigator.vibrate(pattern);

/** Cancel any ongoing vibration
 *  @memberof Input */
const vibrateStop = ()=> vibrate(0);

///////////////////////////////////////////////////////////////////////////////
// Touch input

/** True if a touch device has been detected
 *  @const {boolean}
 *  @memberof Input */
const isTouchDevice = window.ontouchstart !== undefined;

// try to enable touch mouse
if (isTouchDevice)
{
    // handle all touch events the same way
    let wasTouching, hadTouch;
    ontouchstart = ontouchmove = ontouchend = (e)=>
    {
        e.button = 0; // all touches are left click

        // check if touching and pass to mouse events
        const touching = e.touches.length;
        if (touching)
        {
            // fix mobile audio, force it to play a sound on first touch
            hadTouch || zzfx(0, hadTouch=1);

            // set event pos and pass it along
            e.x = e.touches[0].clientX;
            e.y = e.touches[0].clientY;
            wasTouching ? onmousemove(e) : onmousedown(e);
        }
        else if (wasTouching)
            onmouseup(e);

        // set was touching
        wasTouching = touching;

        // must return true so the document will get focus
        return true;
    }
}

///////////////////////////////////////////////////////////////////////////////
// touch gamepad, virtual on screen gamepad emulator for touch devices

// touch input internal variables
let touchGamepadTimer = new Timer, touchGamepadButtons = [], touchGamepadStick = vec2();

// create the touch gamepad, called automatically by the engine
function touchGamepadCreate()
{
    if (!touchGamepadEnable || !isTouchDevice)
        return;

    ontouchstart = ontouchmove = ontouchend = (e)=> 
    {
        if (!touchGamepadEnable)
            return;

        // clear touch gamepad input
        touchGamepadStick = vec2();
        touchGamepadButtons = [];
            
        const touching = e.touches.length;
        if (touching)
        {
            touchGamepadTimer.isSet() || zzfx(0) ; // fix mobile audio, force it to play a sound the first time

            // set that gamepad is active
            isUsingGamepad = 1;
            touchGamepadTimer.set();

            if (paused)
            {
                // touch anywhere to press start when paused
                touchGamepadButtons[9] = 1;
                return;
            }
        }

        // get center of left and right sides
        const stickCenter = vec2(touchGamepadSize, mainCanvasSize.y-touchGamepadSize);
        const buttonCenter = mainCanvasSize.subtract(vec2(touchGamepadSize, touchGamepadSize));
        const startCenter = mainCanvasSize.scale(.5);

        // check each touch point
        for (const touch of e.touches)
        {
            const touchPos = mouseToScreen(vec2(touch.clientX, touch.clientY));
            if (touchPos.distance(stickCenter) &lt; touchGamepadSize)
            {
                // virtual analog stick
                if (touchGamepadAnalog)
                    touchGamepadStick = touchPos.subtract(stickCenter).scale(2/touchGamepadSize).clampLength();
                else
                {
                    // 8 way dpad
                    const angle = touchPos.subtract(stickCenter).angle();
                    touchGamepadStick.setAngle((angle * 4 / PI + 8.5 | 0) * PI / 4);
                }
            }
            else if (touchPos.distance(buttonCenter) &lt; touchGamepadSize)
            {
                // virtual face buttons
                const button = touchPos.subtract(buttonCenter).direction();
                touchGamepadButtons[button] = 1;
            }
            else if (touchPos.distance(startCenter) &lt; touchGamepadSize)
            {
                // virtual start button in center
                touchGamepadButtons[9] = 1;
            }
        }
    }
}

// render the touch gamepad, called automatically by the engine
function touchGamepadRender()
{
    if (!touchGamepadEnable || !touchGamepadTimer.isSet())
        return;
    
    // fade off when not touching or paused
    const alpha = percent(touchGamepadTimer, 4, 3);
    if (!alpha || paused)
        return;

    // setup the canvas
    overlayContext.save();
    overlayContext.globalAlpha = alpha*touchGamepadAlpha;
    overlayContext.strokeStyle = '#fff';
    overlayContext.lineWidth = 3;

    // draw left analog stick
    overlayContext.fillStyle = touchGamepadStick.lengthSquared() > 0 ? '#fff' : '#000';
    overlayContext.beginPath();

    const leftCenter = vec2(touchGamepadSize, mainCanvasSize.y-touchGamepadSize);
    if (touchGamepadAnalog)
    {
        overlayContext.arc(leftCenter.x, leftCenter.y, touchGamepadSize/2, 0, 9);
        overlayContext.fill();
        overlayContext.stroke();
    }
    else // draw cross shaped gamepad
    {
        for(let i=10; i--;)
        {
            const angle = i*PI/4;
            overlayContext.arc(leftCenter.x, leftCenter.y,touchGamepadSize*.6, angle + PI/8, angle + PI/8);
            i%2 &amp;&amp; overlayContext.arc(leftCenter.x, leftCenter.y, touchGamepadSize*.33, angle, angle);
            i==1 &amp;&amp; overlayContext.fill();
        }
        overlayContext.stroke();
    }
    
    // draw right face buttons
    const rightCenter = vec2(mainCanvasSize.x-touchGamepadSize, mainCanvasSize.y-touchGamepadSize);
    for (let i=4; i--;)
    {
        const pos = rightCenter.add((new Vector2).setAngle(i*PI/2, touchGamepadSize/2));
        overlayContext.fillStyle = touchGamepadButtons[i] ? '#fff' : '#000';
        overlayContext.beginPath();
        overlayContext.arc(pos.x, pos.y, touchGamepadSize/4, 0,9);
        overlayContext.fill();
        overlayContext.stroke();
    }

    // set canvas back to normal
    overlayContext.restore();
}
/** 
 * LittleJS Audio System
 * &lt;br> - &lt;a href=https://killedbyapixel.github.io/ZzFX/>ZzFX Sound Effects&lt;/a>
 * &lt;br> - &lt;a href=https://keithclark.github.io/ZzFXM/>ZzFXM Music&lt;/a>
 * &lt;br> - Caches sounds and music for fast playback
 * &lt;br> - Can attenuate and apply stereo panning to sounds
 * &lt;br> - Ability to play mp3, ogg, and wave files
 * &lt;br> - Speech synthesis wrapper functions
 */

'use strict';

/** 
 * Sound Object - Stores a zzfx sound for later use and can be played positionally
 * &lt;br>
 * &lt;br>&lt;b>&lt;a href=https://killedbyapixel.github.io/ZzFX/>Create sounds using the ZzFX Sound Designer.&lt;/a>&lt;/b>
 * @example
 * // create a sound
 * const sound_example = new Sound([.5,.5]);
 * 
 * // play the sound
 * sound_example.play();
 */
class Sound
{
    /** Create a sound object and cache the zzfx samples for later use
     *  @param {Array}  zzfxSound - Array of zzfx parameters, ex. [.5,.5]
     *  @param {Number} [range=soundDefaultRange] - World space max range of sound, will not play if camera is farther away
     *  @param {Number} [taper=soundDefaultTaper] - At what percentage of range should it start tapering off
     */
    constructor(zzfxSound, range=soundDefaultRange, taper=soundDefaultTaper)
    {
        if (!soundEnable) return;

        /** @property {Number} - World space max range of sound, will not play if camera is farther away */
        this.range = range;

        /** @property {Number} - At what percentage of range should it start tapering off */
        this.taper = taper;

        // get randomness from sound parameters
        this.randomness = zzfxSound[1] || 0;
        zzfxSound[1] = 0;

        // generate sound now for fast playback
        this.cachedSamples = zzfxG(...zzfxSound);
    }

    /** Play the sound
     *  @param {Vector2} [pos] - World space position to play the sound, sound is not attenuated if null
     *  @param {Number}  [volume=1] - How much to scale volume by (in addition to range fade)
     *  @param {Number}  [pitch=1] - How much to scale pitch by (also adjusted by this.randomness)
     *  @param {Number}  [randomnessScale=1] - How much to scale randomness
     *  @return {AudioBufferSourceNode} - The audio, can be used to stop sound later
     */
    play(pos, volume=1, pitch=1, randomnessScale=1)
    {
        if (!soundEnable) return;

        let pan = 0;
        if (pos)
        {
            const range = this.range;
            if (range)
            {
                // apply range based fade
                const lengthSquared = cameraPos.distanceSquared(pos);
                if (lengthSquared > range*range)
                    return; // out of range

                // attenuate volume by distance
                volume *= percent(lengthSquared**.5, range, range*this.taper);
            }

            // get pan from screen space coords
            pan = worldToScreen(pos).x * 2/mainCanvas.width - 1;
        }

        // play the sound
        const playbackRate = pitch + pitch * this.randomness*randomnessScale*rand(-1,1);
        return playSamples([this.cachedSamples], volume, playbackRate, pan);
    }

    /** Play the sound as a note with a semitone offset
     *  @param {Number}  semitoneOffset - How many semitones to offset pitch
     *  @param {Vector2} [pos] - World space position to play the sound, sound is not attenuated if null
     *  @param {Number}  [volume=1] - How much to scale volume by (in addition to range fade)
     *  @return {AudioBufferSourceNode} - The audio, can be used to stop sound later
     */
    playNote(semitoneOffset, pos, volume=1)
    {
        if (!soundEnable) return;

        return this.play(pos, volume, 2**(semitoneOffset/12), 0);
    }
}

/**
 * Music Object - Stores a zzfx music track for later use
 * &lt;br>
 * &lt;br>&lt;b>&lt;a href=https://keithclark.github.io/ZzFXM/>Create music with the ZzFXM tracker.&lt;/a>&lt;/b>
 * @example
 * // create some music
 * const music_example = new Music(
 * [
 *     [                         // instruments
 *       [,0,400]                // simple note
 *     ], 
 *     [                         // patterns
 *         [                     // pattern 1
 *             [                 // channel 0
 *                 0, -1,        // instrument 0, left speaker
 *                 1, 0, 9, 1    // channel notes
 *             ], 
 *             [                 // channel 1
 *                 0, 1,         // instrument 1, right speaker
 *                 0, 12, 17, -1 // channel notes
 *             ]
 *         ],
 *     ],
 *     [0, 0, 0, 0], // sequence, play pattern 0 four times
 *     90            // BPM
 * ]);
 * 
 * // play the music
 * music_example.play();
 */
class Music
{
    /** Create a music object and cache the zzfx music samples for later use
     *  @param {Array} zzfxMusic - Array of zzfx music parameters
     */
    constructor(zzfxMusic)
    {
        if (!soundEnable) return;

        this.cachedSamples = zzfxM(...zzfxMusic);
    }

    /** Play the music
     *  @param {Number}  [volume=1] - How much to scale volume by
     *  @param {Boolean} [loop=1] - True if the music should loop when it reaches the end
     *  @return {AudioBufferSourceNode} - The audio node, can be used to stop sound later
     */
    play(volume = 1, loop = 1)
    {
        if (!soundEnable) return;

        return playSamples(this.cachedSamples, volume, 1, 0, loop);
    }
}

/** Play an mp3 or wav audio from a local file or url
 *  @param {String}  url - Location of sound file to play
 *  @param {Number}  [volume=1] - How much to scale volume by
 *  @param {Boolean} [loop=1] - True if the music should loop when it reaches the end
 *  @return {HTMLAudioElement} - The audio element for this sound
 *  @memberof Audio */
function playAudioFile(url, volume=1, loop=1)
{
    if (!soundEnable) return;

    const audio = new Audio(url);
    audio.volume = soundVolume * volume;
    audio.loop = loop;
    audio.play();
    return audio;
}

/** Speak text with passed in settings
 *  @param {String} text - The text to speak
 *  @param {String} [language] - The language/accent to use (examples: en, it, ru, ja, zh)
 *  @param {Number} [volume=1] - How much to scale volume by
 *  @param {Number} [rate=1] - How quickly to speak
 *  @param {Number} [pitch=1] - How much to change the pitch by
 *  @return {SpeechSynthesisUtterance} - The utterance that was spoken
 *  @memberof Audio */
function speak(text, language='', volume=1, rate=1, pitch=1)
{
    if (!soundEnable || !speechSynthesis) return;

    // common languages (not supported by all browsers)
    // en - english,  it - italian, fr - french,  de - german, es - spanish
    // ja - japanese, ru - russian, zh - chinese, hi - hindi,  ko - korean

    // build utterance and speak
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = language;
    utterance.volume = 2*volume*soundVolume;
    utterance.rate = rate;
    utterance.pitch = pitch;
    speechSynthesis.speak(utterance);
    return utterance;
}

/** Stop all queued speech
 *  @memberof Audio */
const speakStop = ()=> speechSynthesis &amp;&amp; speechSynthesis.cancel();

/** Get frequency of a note on a musical scale
 *  @param {Number} semitoneOffset - How many semitones away from the root note
 *  @param {Number} [rootNoteFrequency=220] - Frequency at semitone offset 0
 *  @return {Number} - The frequency of the note
 *  @memberof Audio */
const getNoteFrequency = (semitoneOffset, rootFrequency=220)=> rootFrequency * 2**(semitoneOffset/12); 

///////////////////////////////////////////////////////////////////////////////

/** Audio context used by the engine
 *  @memberof Audio */
let audioContext;

/** Play cached audio samples with given settings
 *  @param {Array}   sampleChannels - Array of arrays of samples to play (for stereo playback)
 *  @param {Number}  [volume=1] - How much to scale volume by
 *  @param {Number}  [rate=1] - The playback rate to use
 *  @param {Number}  [pan=0] - How much to apply stereo panning
 *  @param {Boolean} [loop=0] - True if the sound should loop when it reaches the end
 *  @return {AudioBufferSourceNode} - The audio node of the sound played
 *  @memberof Audio */
function playSamples(sampleChannels, volume=1, rate=1, pan=0, loop=0) 
{
    if (!soundEnable) return;

    // create audio context
    if (!audioContext)
        audioContext = new (window.AudioContext||webkitAudioContext);

    // fix stalled audio
    audioContext.resume();

    // prevent sounds from building up if they can't be played
    if (audioContext.state != 'running')
        return;

    // create buffer and source
    const buffer = audioContext.createBuffer(sampleChannels.length, sampleChannels[0].length, zzfxR), 
        source = audioContext.createBufferSource();

    // copy samples to buffer and setup source
    sampleChannels.forEach((c,i)=> buffer.getChannelData(i).set(c));
    source.buffer = buffer;
    source.playbackRate.value = rate;
    source.loop = loop;

    // create and connect gain node (createGain is more widley spported then GainNode construtor)
    const gainNode = audioContext.createGain();
    gainNode.gain.value = soundVolume*volume;
    gainNode.connect(audioContext.destination);

    // connect source to gain
    (
        window.StereoPannerNode ? // create pan node if possible
        source.connect(new StereoPannerNode(audioContext, {'pan':clamp(pan, -1, 1)}))
        : source
    )
    .connect(gainNode);

    // play and return sound
    source.start();
    return source;
}

///////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth - v1.1.8 by Frank Force

/** Generate and play a ZzFX sound
 *  &lt;br>
 *  &lt;br>&lt;b>&lt;a href=https://killedbyapixel.github.io/ZzFX/>Create sounds using the ZzFX Sound Designer.&lt;/a>&lt;/b>
 *  @param {Array} zzfxSound - Array of ZzFX parameters, ex. [.5,.5]
 *  @return {Array} - Array of audio samples
 *  @memberof Audio */
const zzfx = (...zzfxSound) => playSamples([zzfxG(...zzfxSound)]);

/** Sample rate used for all ZzFX sounds
 *  @default 44100
 *  @memberof Audio */
const zzfxR = 44100; 

/** Generate samples for a ZzFX sound
 *  @memberof Audio */
function zzfxG
(
    // parameters
    volume = 1, randomness = .05, frequency = 220, attack = 0, sustain = 0,
    release = .1, shape = 0, shapeCurve = 1, slide = 0, deltaSlide = 0,
    pitchJump = 0, pitchJumpTime = 0, repeatTime = 0, noise = 0, modulation = 0,
    bitCrush = 0, delay = 0, sustainVolume = 1, decay = 0, tremolo = 0
)
{
    // init parameters
    let PI2 = PI*2, startSlide = slide *= 500 * PI2 / zzfxR / zzfxR, b=[],
        startFrequency = frequency *= (1 + randomness*rand(-1,1)) * PI2 / zzfxR,
        t=0, tm=0, i=0, j=1, r=0, c=0, s=0, f, length;
        
    // scale by sample rate
    attack = attack * zzfxR + 9; // minimum attack to prevent pop
    decay *= zzfxR;
    sustain *= zzfxR;
    release *= zzfxR;
    delay *= zzfxR;
    deltaSlide *= 500 * PI2 / zzfxR**3;
    modulation *= PI2 / zzfxR;
    pitchJump *= PI2 / zzfxR;
    pitchJumpTime *= zzfxR;
    repeatTime = repeatTime * zzfxR | 0;

    // generate waveform
    for (length = attack + decay + sustain + release + delay | 0;
        i &lt; length; b[i++] = s)
    {
        if (!(++c%(bitCrush*100|0)))                      // bit crush
        {
            s = shape? shape>1? shape>2? shape>3?         // wave shape
                Math.sin((t%PI2)**3) :                    // 4 noise
                max(min(Math.tan(t),1),-1):               // 3 tan
                1-(2*t/PI2%2+2)%2:                        // 2 saw
                1-4*abs(Math.round(t/PI2)-t/PI2):         // 1 triangle
                Math.sin(t);                              // 0 sin
                
            s = (repeatTime ?
                    1 - tremolo + tremolo*Math.sin(PI2*i/repeatTime) // tremolo
                    : 1) *
                sign(s)*(abs(s)**shapeCurve) *            // curve 0=square, 2=pointy
                volume * soundVolume * (                  // envelope
                i &lt; attack ? i/attack :                   // attack
                i &lt; attack + decay ?                      // decay
                1-((i-attack)/decay)*(1-sustainVolume) :  // decay falloff
                i &lt; attack  + decay + sustain ?           // sustain
                sustainVolume :                           // sustain volume
                i &lt; length - delay ?                      // release
                (length - i - delay)/release *            // release falloff
                sustainVolume :                           // release volume
                0);                                       // post release
 
            s = delay ? s/2 + (delay > i ? 0 :            // delay
                (i&lt;length-delay? 1 : (length-i)/delay) *  // release delay 
                b[i-delay|0]/2) : s;                      // sample delay
        }

        f = (frequency += slide += deltaSlide) *          // frequency
            Math.cos(modulation*tm++);                    // modulation
        t += f - f*noise*(1 - (Math.sin(i)+1)*1e9%2);     // noise

        if (j &amp;&amp; ++j > pitchJumpTime)       // pitch jump
        {
            frequency += pitchJump;         // apply pitch jump
            startFrequency += pitchJump;    // also apply to start
            j = 0;                          // reset pitch jump time
        }

        if (repeatTime &amp;&amp; !(++r % repeatTime)) // repeat
        {
            frequency = startFrequency;     // reset frequency
            slide = startSlide;             // reset slide
            j = j || 1;                     // reset pitch jump time
        }
    }
    
    return b;
}

///////////////////////////////////////////////////////////////////////////////
// ZzFX Music Renderer v2.0.3 by Keith Clark and Frank Force

/** Generate samples for a ZzFM song with given parameters
 *  @param {Array} instruments - Array of ZzFX sound paramaters
 *  @param {Array} patterns - Array of pattern data
 *  @param {Array} sequence - Array of pattern indexes
 *  @param {Number} [BPM=125] - Playback speed of the song in BPM
 *  @returns {Array} - Left and right channel sample data
 *  @memberof Audio */
function zzfxM(instruments, patterns, sequence, BPM = 125) 
{
  let instrumentParameters;
  let i;
  let j;
  let k;
  let note;
  let sample;
  let patternChannel;
  let notFirstBeat;
  let stop;
  let instrument;
  let attenuation;
  let outSampleOffset;
  let isSequenceEnd;
  let sampleOffset = 0;
  let nextSampleOffset;
  let sampleBuffer = [];
  let leftChannelBuffer = [];
  let rightChannelBuffer = [];
  let channelIndex = 0;
  let panning = 0;
  let hasMore = 1;
  let sampleCache = {};
  let beatLength = zzfxR / BPM * 60 >> 2;

  // for each channel in order until there are no more
  for (; hasMore; channelIndex++) {

    // reset current values
    sampleBuffer = [hasMore = notFirstBeat = outSampleOffset = 0];

    // for each pattern in sequence
    sequence.forEach((patternIndex, sequenceIndex) => {
      // get pattern for current channel, use empty 1 note pattern if none found
      patternChannel = patterns[patternIndex][channelIndex] || [0, 0, 0];

      // check if there are more channels
      hasMore |= !!patterns[patternIndex][channelIndex];

      // get next offset, use the length of first channel
      nextSampleOffset = outSampleOffset + (patterns[patternIndex][0].length - 2 - !notFirstBeat) * beatLength;
      // for each beat in pattern, plus one extra if end of sequence
      isSequenceEnd = sequenceIndex == sequence.length - 1;
      for (i = 2, k = outSampleOffset; i &lt; patternChannel.length + isSequenceEnd; notFirstBeat = ++i) {

        // &lt;channel-note>
        note = patternChannel[i];

        // stop if end, different instrument or new note
        stop = i == patternChannel.length + isSequenceEnd - 1 &amp;&amp; isSequenceEnd ||
            instrument != (patternChannel[0] || 0) | note | 0;

        // fill buffer with samples for previous beat, most cpu intensive part
        for (j = 0; j &lt; beatLength &amp;&amp; notFirstBeat;

            // fade off attenuation at end of beat if stopping note, prevents clicking
            j++ > beatLength - 99 &amp;&amp; stop ? attenuation += (attenuation &lt; 1) / 99 : 0
        ) {
          // copy sample to stereo buffers with panning
          sample = (1 - attenuation) * sampleBuffer[sampleOffset++] / 2 || 0;
          leftChannelBuffer[k] = (leftChannelBuffer[k] || 0) - sample * panning + sample;
          rightChannelBuffer[k] = (rightChannelBuffer[k++] || 0) + sample * panning + sample;
        }

        // set up for next note
        if (note) {
          // set attenuation
          attenuation = note % 1;
          panning = patternChannel[1] || 0;
          if (note |= 0) {
            // get cached sample
            sampleBuffer = sampleCache[
              [
                instrument = patternChannel[sampleOffset = 0] || 0,
                note
              ]
            ] = sampleCache[[instrument, note]] || (
                // add sample to cache
                instrumentParameters = [...instruments[instrument]],
                instrumentParameters[2] *= 2 ** ((note - 12) / 12),

                // allow negative values to stop notes
                note > 0 ? zzfxG(...instrumentParameters) : []
            );
          }
        }
      }

      // update the sample offset
      outSampleOffset = nextSampleOffset;
    });
  }

  return [leftChannelBuffer, rightChannelBuffer];
}
/** 
 * LittleJS Tile Layer System
 * &lt;br> - Caches arrays of tiles to off screen canvas for fast rendering
 * &lt;br> - Unlimted numbers of layers, allocates canvases as needed
 * &lt;br> - Interfaces with EngineObject for collision
 * &lt;br> - Collision layer is separate from visible layers
 * &lt;br> - It is recommended to have a visible layer that matches the collision
 * &lt;br> - Tile layers can be drawn to using their context with canvas2d
 * &lt;br> - Drawn directly to the main canvas without using WebGL
 * @namespace TileCollision
 */

'use strict';

/** The tile collision layer array, use setTileCollisionData and getTileCollisionData to access
 *  @memberof TileCollision */
let tileCollision = [];

/** Size of the tile collision layer
 *  @type {Vector2} 
 *  @memberof TileCollision */
let tileCollisionSize = vec2();

/** Clear and initialize tile collision
 *  @param {Vector2} size
 *  @memberof TileCollision */
function initTileCollision(size)
{
    tileCollisionSize = size;
    tileCollision = [];
    for (let i=tileCollision.length = tileCollisionSize.area(); i--;)
        tileCollision[i] = 0;
}

/** Set tile collision data
 *  @param {Vector2} pos
 *  @param {Number}  [data=0]
 *  @memberof TileCollision */
const setTileCollisionData = (pos, data=0)=>
    pos.arrayCheck(tileCollisionSize) &amp;&amp; (tileCollision[(pos.y|0)*tileCollisionSize.x+pos.x|0] = data);

/** Get tile collision data
 *  @param {Vector2} pos
 *  @return {Number}
 *  @memberof TileCollision */
const getTileCollisionData = (pos)=>
    pos.arrayCheck(tileCollisionSize) ? tileCollision[(pos.y|0)*tileCollisionSize.x+pos.x|0] : 0;

/** Check if collision with another object should occur
 *  @param {Vector2}      pos
 *  @param {Vector2}      [size=new Vector2(1,1)]
 *  @param {EngineObject} [object]
 *  @return {Boolean}
 *  @memberof TileCollision */
function tileCollisionTest(pos, size=vec2(), object)
{
    const minX = max(pos.x - size.x/2|0, 0);
    const minY = max(pos.y - size.y/2|0, 0);
    const maxX = min(pos.x + size.x/2, tileCollisionSize.x);
    const maxY = min(pos.y + size.y/2, tileCollisionSize.y);
    for (let y = minY; y &lt; maxY; ++y)
    for (let x = minX; x &lt; maxX; ++x)
    {
        const tileData = tileCollision[y*tileCollisionSize.x+x];
        if (tileData &amp;&amp; (!object || object.collideWithTile(tileData, new Vector2(x, y))))
            return 1;
    }
}

/** Return the center of tile if any that is hit (this does not return the exact hit point)
 *  @param {Vector2}      posStart
 *  @param {Vector2}      posEnd
 *  @param {EngineObject} [object]
 *  @return {Vector2}
 *  @memberof TileCollision */
function tileCollisionRaycast(posStart, posEnd, object)
{
    // test if a ray collides with tiles from start to end
    // todo: a way to get the exact hit point, it must still register as inside the hit tile
    posStart = posStart.floor();
    posEnd = posEnd.floor();
    const posDelta = posEnd.subtract(posStart);
    const dx = abs(posDelta.x),  dy = -abs(posDelta.y);
    const sx = sign(posDelta.x), sy = sign(posDelta.y);
    let e = dx + dy;

    for (let x = posStart.x, y = posStart.y;;)
    {
        const tileData = getTileCollisionData(vec2(x,y));
        if (tileData &amp;&amp; (object ? object.collideWithTileRaycast(tileData, new Vector2(x, y)) : tileData > 0))
        {
            debugRaycast &amp;&amp; debugLine(posStart, posEnd, '#f00',.02, 1);
            debugRaycast &amp;&amp; debugPoint(new Vector2(x+.5, y+.5), '#ff0', 1);
            return new Vector2(x+.5, y+.5);
        }

        // update Bresenham line drawing algorithm
        if (x == posEnd.x &amp; y == posEnd.y) break;
        const e2 = 2*e;
        if (e2 >= dy) e += dy, x += sx;
        if (e2 &lt;= dx) e += dx, y += sy;
    }
    debugRaycast &amp;&amp; debugLine(posStart, posEnd, '#00f',.02, 1);
}

///////////////////////////////////////////////////////////////////////////////
// Tile Layer Rendering System

/**
 * Tile layer data object stores info about how to render a tile
 * @example
 * // create tile layer data with tile index 0 and random orientation and color
 * const tileIndex = 0;
 * const direction = randInt(4)
 * const mirror = randInt(2);
 * const color = randColor();
 * const data = new TileLayerData(tileIndex, direction, mirror, color);
 */
class TileLayerData
{
    /** Create a tile layer data object, one for each tile in a TileLayer
     *  @param {Number}  [tile]                   - The tile to use, untextured if undefined
     *  @param {Number}  [direction=0]            - Integer direction of tile, in 90 degree increments
     *  @param {Boolean} [mirror=0]               - If the tile should be mirrored along the x axis
     *  @param {Color}   [color=new Color(1,1,1)] - Color of the tile */
    constructor(tile, direction=0, mirror=0, color=new Color)
    {
        /** @property {Number}  - The tile to use, untextured if undefined */
        this.tile      = tile;
        /** @property {Number}  - Integer direction of tile, in 90 degree increments */
        this.direction = direction;
        /** @property {Boolean} - If the tile should be mirrored along the x axis */
        this.mirror    = mirror;
        /** @property {Color}   - Color of the tile */
        this.color     = color;
    }

    /** Set this tile to clear, it will not be rendered */
    clear() { this.tile = this.direction = this.mirror = 0; color = new Color; }
}

/**
 * Tile layer object - cached rendering system for tile layers
 * &lt;br> - Each Tile layer is rendered to an off screen canvas
 * &lt;br> - To allow dynamic modifications, layers are rendered using canvas 2d
 * &lt;br> - Some devices like mobile phones are limited to 4k texture resolution
 * &lt;br> - So with 16x16 tiles this limits layers to 256x256 on mobile devices
 * @extends EngineObject
 * @example
 * // create tile collision and visible tile layer
 * initTileCollision(vec2(200,100));
 * const tileLayer = new TileLayer();
 */
class TileLayer extends EngineObject
{
/** Create a tile layer object
    *  @param {Vector2} [position=new Vector2()]   - World space position
    *  @param {Vector2} [size=tileCollisionSize]   - World space size
    *  @param {Vector2} [tileSize=tileSizeDefault] - Size of tiles in source pixels
    *  @param {Vector2} [scale=new Vector2(1,1)]   - How much to scale this layer when rendered
    *  @param {Number}  [renderOrder=0]            - Objects sorted by renderOrder before being rendered
    */
constructor(pos, size=tileCollisionSize, tileSize=tileSizeDefault, scale=vec2(1), renderOrder=0)
    {
        super(pos, size, -1, tileSize, 0, undefined, renderOrder);

        /** @property {HTMLCanvasElement}        - The canvas used by this tile layer */
        this.canvas = document.createElement('canvas');
        /** @property {CanvasRenderingContext2D} - The 2D canvas context used by this tile layer */
        this.context = this.canvas.getContext('2d');
        /** @property {Vector2}                  - How much to scale this layer when rendered */
        this.scale = scale;
        /** @property {Boolean} [isOverlay=0]    - If true this layer will render to overlay canvas and appear above all objects */
        this.isOverlay;

        // init tile data
        this.data = [];
        for (let j = this.size.area(); j--;)
            this.data.push(new TileLayerData());
    }
    
    /** Set data at a given position in the array 
     *  @param {Vector2}       position   - Local position in array
     *  @param {TileLayerData} data       - Data to set
     *  @param {Boolean}       [redraw=0] - Force the tile to redraw if true */
    setData(layerPos, data, redraw)
    {
        if (layerPos.arrayCheck(this.size))
        {
            this.data[(layerPos.y|0)*this.size.x+layerPos.x|0] = data;
            redraw &amp;&amp; this.drawTileData(layerPos);
        }
    }
    
    /** Get data at a given position in the array 
     *  @param {Vector2} layerPos - Local position in array
     *  @return {TileLayerData} */
    getData(layerPos)
    { return layerPos.arrayCheck(this.size) &amp;&amp; this.data[(layerPos.y|0)*this.size.x+layerPos.x|0]; }
    
    // Tile layers are not updated
    update() {}

    // Render the tile layer, called automatically by the engine
    render()
    {
        ASSERT(mainContext != this.context); // must call redrawEnd() after drawing tiles

        // flush and copy gl canvas because tile canvas does not use webgl
        glEnable &amp;&amp; !glOverlay &amp;&amp; !this.isOverlay &amp;&amp; glCopyToContext(mainContext);
        
        // draw the entire cached level onto the canvas
        const pos = worldToScreen(this.pos.add(vec2(0,this.size.y*this.scale.y)));
        (this.isOverlay ? overlayContext : mainContext).drawImage
        (
            this.canvas, pos.x, pos.y,
            cameraScale*this.size.x*this.scale.x, cameraScale*this.size.y*this.scale.y
        );
    }

    /** Draw all the tile data to an offscreen canvas 
     *  - This may be slow in some browsers
    */
    redraw()
    {
        this.redrawStart(1);
        this.drawAllTileData();
        this.redrawEnd();
    }

    /** Call to start the redraw process
     *  @param {Boolean} [clear=0] - Should it clear the canvas before drawing */
    redrawStart(clear = 0)
    {
        if (clear)
        {
            // clear and set size
            this.canvas.width  = this.size.x * this.tileSize.x;
            this.canvas.height = this.size.y * this.tileSize.y;
        }

        // save current render settings
        this.savedRenderSettings = [mainCanvas, mainContext, cameraPos, cameraScale];

        // use normal rendering system to render the tiles
        mainCanvas = this.canvas;
        mainContext = this.context;
        cameraPos = this.size.scale(.5);
        cameraScale = this.tileSize.x;
        enginePreRender();
    }

    /** Call to end the redraw process */
    redrawEnd()
    {
        ASSERT(mainContext == this.context); // must call redrawStart() before drawing tiles
        glEnable &amp;&amp; glCopyToContext(mainContext, 1);
        //debugSaveCanvas(this.canvas);

        // set stuff back to normal
        [mainCanvas, mainContext, cameraPos, cameraScale] = this.savedRenderSettings;
    }

    /** Draw the tile at a given position
     *  @param {Vector2} layerPos */
    drawTileData(layerPos)
    {
        // first clear out where the tile was
        const pos = layerPos.floor().add(this.pos).add(vec2(.5));
        this.drawCanvas2D(pos, vec2(1), 0, 0, (context)=>context.clearRect(-.5, -.5, 1, 1));

        // draw the tile if not undefined
        const d = this.getData(layerPos);
        if (d.tile != undefined)
        {
            ASSERT(mainContext == this.context); // must call redrawStart() before drawing tiles
            drawTile(pos, vec2(1), d.tile, this.tileSize, d.color, d.direction*PI/2, d.mirror);
        }
    }

    /** Draw all the tiles in this layer */
    drawAllTileData()
    {
        for (let x = this.size.x; x--;)
        for (let y = this.size.y; y--;)
             this.drawTileData(vec2(x,y));
    }

    /** Draw directly to the 2D canvas in world space (bipass webgl)
     *  @param {Vector2}  pos
     *  @param {Vector2}  size
     *  @param {Number}   [angle=0]
     *  @param {Boolean}  [mirror=0]
     *  @param {Function} drawFunction */
    drawCanvas2D(pos, size, angle=0, mirror, drawFunction)
    {
        const context = this.context;
        context.save();
        pos = pos.subtract(this.pos).multiply(this.tileSize);
        size = size.multiply(this.tileSize);
        context.translate(pos.x, this.canvas.height - pos.y);
        context.rotate(angle);
        context.scale(mirror ? -size.x : size.x, size.y);
        drawFunction(context);
        context.restore();
    }

    /** Draw a tile directly onto the layer canvas
     *  @param {Vector2} pos
     *  @param {Vector2} [size=new Vector2(1,1)]
     *  @param {Number}  [tileIndex=-1]
     *  @param {Vector2} [tileSize=tileSizeDefault]
     *  @param {Color}   [color=new Color(1,1,1)]
     *  @param {Number}  [angle=0]
     *  @param {Boolean} [mirror=0] */
    drawTile(pos, size=vec2(1), tileIndex=-1, tileSize=tileSizeDefault, color=new Color, angle, mirror)
    {
        this.drawCanvas2D(pos, size, angle, mirror, (context)=>
        {
            if (tileIndex &lt; 0)
            {
                // untextured
                context.fillStyle = color;
                context.fillRect(-.5, -.5, 1, 1);
            }
            else
            {
                const cols = tileImage.width/tileSize.x;
                context.globalAlpha = color.a; // only alpha, no color, is supported in this mode
                context.drawImage(tileImage, 
                    (tileIndex%cols)*tileSize.x, (tileIndex/cols|0)*tileSize.y, 
                    tileSize.x, tileSize.y, -.5, -.5, 1, 1);
            }
        });
    }

    /** Draw a rectangle directly onto the layer canvas
     *  @param {Vector2} pos
     *  @param {Vector2} [size=new Vector2(1,1)]
     *  @param {Color}   [color=new Color(1,1,1)]
     *  @param {Number}  [angle=0] */
    drawRect(pos, size, color, angle) 
    { this.drawTile(pos, size, -1, 0, color, angle); }
}
/*
    LittleJS Particle System
    - Spawns particles with randomness from parameters
    - Updates particle physics
    - Fast particle rendering
*/

'use strict';

/**
 * Particle Emitter - Spawns particles with the given settings
 * @extends EngineObject
 * @example
 * // create a particle emitter
 * let pos = vec2(2,3);
 * let particleEmiter = new ParticleEmitter
 * (
 *     pos, 0, 1, 0, 500, PI,  // pos, angle, emitSize, emitTime, emitRate, emiteCone
 *     0, vec2(16),                            // tileIndex, tileSize
 *     new Color(1,1,1),   new Color(0,0,0),   // colorStartA, colorStartB
 *     new Color(1,1,1,0), new Color(0,0,0,0), // colorEndA, colorEndB
 *     2, .2, .2, .1, .05,  // particleTime, sizeStart, sizeEnd, particleSpeed, particleAngleSpeed
 *     .99, 1, 1, PI, .05,  // damping, angleDamping, gravityScale, particleCone, fadeRate, 
 *     .5, 1                // randomness, collide, additive, randomColorLinear, renderOrder
 * );
 */
class ParticleEmitter extends EngineObject
{
    /** Create a particle system with the given settings
     *  @param {Vector2} position           - World space position of the emitter
     *  @param {Number}  [angle=0]          - Angle to emit the particles
     *  @param {Number}  [emitSize=0]       - World space size of the emitter (float for circle diameter, vec2 for rect)
     *  @param {Number}  [emitTime=0]       - How long to stay alive (0 is forever)
     *  @param {Number}  [emitRate=100]     - How many particles per second to spawn, does not emit if 0
     *  @param {Number}  [emitConeAngle=PI] - Local angle to apply velocity to particles from emitter
     *  @param {Number}  [tileIndex=-1]     - Index into tile sheet, if &lt;0 no texture is applied
     *  @param {Number}  [tileSize=tileSizeDefault]     - Tile size for particles
     *  @param {Color}   [colorStartA=new Color(1,1,1)] - Color at start of life 1, randomized between start colors
     *  @param {Color}   [colorStartB=new Color(1,1,1)] - Color at start of life 2, randomized between start colors
     *  @param {Color}   [colorEndA=new Color(1,1,1,0)] - Color at end of life 1, randomized between end colors
     *  @param {Color}   [colorEndB=new Color(1,1,1,0)] - Color at end of life 2, randomized between end colors
     *  @param {Number}  [particleTime=.5]      - How long particles live
     *  @param {Number}  [sizeStart=.1]         - How big are particles at start
     *  @param {Number}  [sizeEnd=1]            - How big are particles at end
     *  @param {Number}  [speed=.1]             - How fast are particles when spawned
     *  @param {Number}  [angleSpeed=.05]       - How fast are particles rotating
     *  @param {Number}  [damping=1]            - How much to dampen particle speed
     *  @param {Number}  [angleDamping=1]       - How much to dampen particle angular speed
     *  @param {Number}  [gravityScale=0]       - How much does gravity effect particles
     *  @param {Number}  [particleConeAngle=PI] - Cone for start particle angle
     *  @param {Number}  [fadeRate=.1]          - How quick to fade in particles at start/end in percent of life
     *  @param {Number}  [randomness=.2]        - Apply extra randomness percent
     *  @param {Boolean} [collideTiles=0]       - Do particles collide against tiles
     *  @param {Boolean} [additive=0]           - Should particles use addtive blend
     *  @param {Boolean} [randomColorLinear=1]  - Should color be randomized linearly or across each component
     *  @param {Number}  [renderOrder=0]        - Render order for particles (additive is above other stuff by default)
     *  @param {Boolean}  [localSpace=0]        - Should it be in local space of emitter (world space is default)
     */
    constructor
    ( 
        pos,
        angle,
        emitSize = 0,
        emitTime = 0,
        emitRate = 100,
        emitConeAngle = PI,
        tileIndex = -1,
        tileSize = tileSizeDefault,
        colorStartA = new Color,
        colorStartB = new Color,
        colorEndA = new Color(1,1,1,0),
        colorEndB = new Color(1,1,1,0),
        particleTime = .5,
        sizeStart = .1,
        sizeEnd = 1,
        speed = .1,
        angleSpeed = .05,
        damping = 1,
        angleDamping = 1,
        gravityScale = 0,
        particleConeAngle = PI,
        fadeRate = .1,
        randomness = .2, 
        collideTiles,
        additive,
        randomColorLinear = 1,
        renderOrder = additive ? 1e9 : 0,
        localSpace
    )
    {
        super(pos, new Vector2, tileIndex, tileSize, angle, undefined, renderOrder);

        // emitter settings
        /** @property {Number} - World space size of the emitter (float for circle diameter, vec2 for rect) */
        this.emitSize = emitSize
        /** @property {Number} - How long to stay alive (0 is forever) */
        this.emitTime = emitTime;
        /** @property {Number} - How many particles per second to spawn, does not emit if 0 */
        this.emitRate = emitRate;
        /** @property {Number} - Local angle to apply velocity to particles from emitter */
        this.emitConeAngle = emitConeAngle;

        // color settings
        /** @property {Color} - Color at start of life 1, randomized between start colors */
        this.colorStartA = colorStartA;
        /** @property {Color} - Color at start of life 2, randomized between start colors */
        this.colorStartB = colorStartB;
        /** @property {Color} - Color at end of life 1, randomized between end colors */
        this.colorEndA   = colorEndA;
        /** @property {Color} - Color at end of life 2, randomized between end colors */
        this.colorEndB   = colorEndB;
        /** @property {Boolean} - Should color be randomized linearly or across each component */
        this.randomColorLinear = randomColorLinear;

        // particle settings
        /** @property {Number} - How long particles live */
        this.particleTime      = particleTime;
        /** @property {Number} - How big are particles at start */
        this.sizeStart         = sizeStart;
        /** @property {Number} - How big are particles at end */
        this.sizeEnd           = sizeEnd;
        /** @property {Number} - How fast are particles when spawned */
        this.speed             = speed;
        /** @property {Number} - How fast are particles rotating */
        this.angleSpeed        = angleSpeed;
        /** @property {Number} - How much to dampen particle speed */
        this.damping           = damping;
        /** @property {Number} - How much to dampen particle angular speed */
        this.angleDamping      = angleDamping;
        /** @property {Number} - How much does gravity effect particles */
        this.gravityScale      = gravityScale;
        /** @property {Number} - Cone for start particle angle */
        this.particleConeAngle = particleConeAngle;
        /** @property {Number} - How quick to fade in particles at start/end in percent of life */
        this.fadeRate          = fadeRate;
        /** @property {Number} - Apply extra randomness percent */
        this.randomness        = randomness;
        /** @property {Number} - Do particles collide against tiles */
        this.collideTiles      = collideTiles;
        /** @property {Number} - Should particles use addtive blend */
        this.additive          = additive;
        /** @property {Boolean} - Should it be in local space of emitter */
        this.localSpace          = localSpace;
        /** @property {Number} - If set the partile is drawn as a trail, stretched in the drection of velocity */
        this.trailScale        = 0;

        // internal variables
        this.emitTimeBuffer    = 0;
    }
    
    /** Update the emitter to spawn particles, called automatically by engine once each frame */
    update()
    {
        // only do default update to apply parent transforms
        this.parent &amp;&amp; super.update();

        // update emitter
        if (!this.emitTime || this.getAliveTime() &lt;= this.emitTime)
        {
            // emit particles
            if (this.emitRate * particleEmitRateScale)
            {
                const rate = 1/this.emitRate/particleEmitRateScale;
                for (this.emitTimeBuffer += timeDelta; this.emitTimeBuffer > 0; this.emitTimeBuffer -= rate)
                    this.emitParticle();
            }
        }
        else
            this.destroy();

        debugParticles &amp;&amp; debugRect(this.pos, vec2(this.emitSize), '#0f0', 0, this.angle);
    }

    /** Spawn one particle
     *  @return {Particle} */
    emitParticle()
    {
        // spawn a particle
        let pos = this.emitSize.x != undefined ? // check if vec2 was used for size
            (new Vector2(rand(-.5,.5), rand(-.5,.5)))
                .multiply(this.emitSize).rotate(this.angle) // box emitter
            : randInCircle(this.emitSize * .5);             // circle emitter
        let angle = rand(this.particleConeAngle, -this.particleConeAngle);
        if (!this.localSpace)
        {
            pos = this.pos.add(pos);
            angle += this.angle;
        }
            
        const particle = new Particle(pos, this.tileIndex, this.tileSize, angle);

        // randomness scales each paremeter by a percentage
        const randomness = this.randomness;
        const randomizeScale = (v)=> v + v*rand(randomness, -randomness);

        // randomize particle settings
        const particleTime  = randomizeScale(this.particleTime);
        const sizeStart     = randomizeScale(this.sizeStart);
        const sizeEnd       = randomizeScale(this.sizeEnd);
        const speed         = randomizeScale(this.speed);
        const angleSpeed    = randomizeScale(this.angleSpeed) * randSign();
        const coneAngle     = rand(this.emitConeAngle, -this.emitConeAngle);
        const colorStart    = randColor(this.colorStartA, this.colorStartB, this.randomColorLinear);
        const colorEnd      = randColor(this.colorEndA,   this.colorEndB, this.randomColorLinear);
        const velocityAngle = this.localSpace ? coneAngle : this.angle + coneAngle;

        // build particle settings
        particle.colorStart    = colorStart;
        particle.colorEndDelta = colorEnd.subtract(colorStart);
        particle.velocity      = (new Vector2).setAngle(velocityAngle, speed);
        particle.angleVelocity = angleSpeed;
        particle.lifeTime      = particleTime;
        particle.sizeStart     = sizeStart;
        particle.sizeEndDelta  = sizeEnd - sizeStart;
        particle.fadeRate      = this.fadeRate;
        particle.damping       = this.damping;
        particle.angleDamping  = this.angleDamping;
        particle.elasticity    = this.elasticity;
        particle.friction      = this.friction;
        particle.gravityScale  = this.gravityScale;
        particle.collideTiles  = this.collideTiles;
        particle.additive      = this.additive;
        particle.renderOrder   = this.renderOrder;
        particle.trailScale    = this.trailScale;
        particle.mirror        = rand()&lt;.5;
        particle.localSpaceEmitter = this.localSpace &amp;&amp; this;

        // setup callbacks for particles
        particle.destroyCallback = this.particleDestroyCallback;
        this.particleCreateCallback &amp;&amp; this.particleCreateCallback(particle);

        // return the newly created particle
        return particle;
    }

    // Particle emitters are not rendered, only the particles are
    render() {}
}

///////////////////////////////////////////////////////////////////////////////
/**
 * Particle Object - Created automatically by Particle Emitters
 * @extends EngineObject
 */
class Particle extends EngineObject
{
    /**
     * Create a particle with the given settings
     * @param {Vector2} position                   - World space position of the particle
     * @param {Number}  [tileIndex=-1]             - Tile to use to render, untextured if -1
     * @param {Vector2} [tileSize=tileSizeDefault] - Size of tile in source pixels
     * @param {Number}  [angle=0]                  - Angle to rotate the particle
     */
    constructor(pos, tileIndex, tileSize, angle) { super(pos, new Vector2, tileIndex, tileSize, angle); }

    /** Render the particle, automatically called each frame, sorted by renderOrder */
    render()
    {
        // modulate size and color
        const p = min((time - this.spawnTime) / this.lifeTime, 1);
        const radius = this.sizeStart + p * this.sizeEndDelta;
        const size = new Vector2(radius, radius);
        const fadeRate = this.fadeRate/2;
        const color = new Color(
            this.colorStart.r + p * this.colorEndDelta.r,
            this.colorStart.g + p * this.colorEndDelta.g,
            this.colorStart.b + p * this.colorEndDelta.b,
            (this.colorStart.a + p * this.colorEndDelta.a) * 
             (p &lt; fadeRate ? p/fadeRate : p > 1-fadeRate ? (1-p)/fadeRate : 1)); // fade alpha

        // draw the particle
        this.additive &amp;&amp; setBlendMode(1);

        let pos = this.pos, angle = this.angle;
        if (this.localSpaceEmitter)
        {
            // in local space of emitter
            pos = this.localSpaceEmitter.pos.add(pos.rotate(-this.localSpaceEmitter.angle)); 
            angle += this.localSpaceEmitter.angle;
        }
        if (this.trailScale)
        {
            // trail style particles
            let velocity = this.velocity;
            if (this.localSpaceEmitter)
                velocity = velocity.rotate(-this.localSpaceEmitter.angle);
            const speed = velocity.length();
            const direction = velocity.scale(1/speed);
            const trailLength = speed * this.trailScale;
            size.y = max(size.x, trailLength);
            angle = direction.angle();
            drawTile(pos.add(direction.multiply(vec2(0,-trailLength/2))), size, this.tileIndex, this.tileSize, color, angle, this.mirror);
        }
        else
            drawTile(pos, size, this.tileIndex, this.tileSize, color, angle, this.mirror);
        this.additive &amp;&amp; setBlendMode();
        debugParticles &amp;&amp; debugRect(pos, size, '#f005', 0, angle);

        if (p == 1)
        {
            // destroy particle when it's time runs out
            this.color = color;
            this.size = size;
            this.destroyCallback &amp;&amp; this.destroyCallback(this);
            this.destroyed = 1;
        }
    }
}
/** 
 * LittleJS Medal System
 * &lt;br> - Tracks and displays medals
 * &lt;br> - Saves medals to local storage
 * &lt;br> - Newgrounds and OS13k integration
 * @namespace Medals
 */

'use strict';

/** List of all medals
 *  @memberof Medals */
const medals = [];

/** Set to stop medals from being unlockable (like if cheats are enabled)
 *  @memberof Medals */
let medalsPreventUnlock;

// Engine internal variables not exposed to documentation
let medalsDisplayQueue = [], medalsSaveName, medalsDisplayTimeLast;

///////////////////////////////////////////////////////////////////////////////

/** Initialize medals with a save name used for storage
 *  &lt;br> - Call this after creating all medals
 *  &lt;br> - Checks if medals are unlocked
 *  @param {String} saveName
 *  @memberof Medals */
function medalsInit(saveName)
{
    // check if medals are unlocked
    medalsSaveName = saveName;
    debugMedals || medals.forEach(medal=> medal.unlocked = (localStorage[medal.storageKey()] | 0));
}

/** 
 * Medal Object - Tracks an unlockable medal 
 * @example
 * // create a medal
 * const medal_example = new Medal(0, 'Example Medal', 'More info about the medal goes here.', '🎖️');
 * 
 * // initialize medals
 * medalsInit('Example Game');
 * 
 * // unlock the medal
 * medal_example.unlock();
 */
class Medal
{
    /** Create an medal object and adds it to the list of medals
     *  @param {Number} id            - The unique identifier of the medal
     *  @param {String} name          - Name of the medal
     *  @param {String} [description] - Description of the medal
     *  @param {String} [icon='🏆']  - Icon for the medal
     *  @param {String} [src]         - Image location for the medal
     */
    constructor(id, name, description='', icon='🏆', src)
    {
        ASSERT(id >= 0 &amp;&amp; !medals[id]);

        // save attributes and add to list of medals
        medals[this.id = id] = this;
        this.name = name;
        this.description = description;
        this.icon = icon;
        this.image = new Image();
        if (src)
            this.image.src = src;
    }

    /** Unlocks a medal if not already unlocked */
    unlock()
    {
        if (medalsPreventUnlock || this.unlocked)
            return;

        // save the medal
        ASSERT(medalsSaveName); // save name must be set
        localStorage[this.storageKey()] = this.unlocked = 1;
        medalsDisplayQueue.push(this);

        // save for newgrounds and OS13K
        newgrounds &amp;&amp; newgrounds.unlockMedal(this.id);
        localStorage['OS13kTrophy,' + this.icon + ',' + medalsSaveName + ',' + this.name] = this.description;
    }

    /** Render a medal
     *  @param {Number} [hidePercent=0] - How much to slide the medal off screen
     */
    render(hidePercent=0)
    {
        const context = overlayContext;
        const width = min(medalDisplayWidth, mainCanvas.width);
        const x = overlayCanvas.width - width;
        const y = -medalDisplayHeight*hidePercent;

        // draw containing rect and clip to that region
        context.save();
        context.beginPath();
        context.fillStyle = '#ddd'
        context.fill(context.rect(x, y, width, medalDisplayHeight));
        context.strokeStyle = '#000';
        context.lineWidth = 3;
        context.stroke();
        context.clip();

        // draw the icon and text
        this.renderIcon(x+15+medalDisplayIconSize/2, y+medalDisplayHeight/2);
        context.textAlign = 'left';
        context.font = '38px '+ fontDefault;
        context.fillText(this.name, x+medalDisplayIconSize+30, y+28);
        context.font = '24px '+ fontDefault;
        context.fillText(this.description, x+medalDisplayIconSize+30, y+60);
        context.restore();
    }

    /** Render the icon for a medal
     *  @param {Number} x - Screen space X position
     *  @param {Number} y - Screen space Y position
     *  @param {Number} [size=medalDisplayIconSize] - Screen space size
     */
    renderIcon(x, y, size=medalDisplayIconSize)
    {
        // draw the image or icon
        const context = overlayContext;
        context.fillStyle = '#000';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.font = size*.7 + 'px '+ fontDefault;
        if (this.image.src)
            context.drawImage(this.image, x-size/2, y-size/2, size, size);
        else
            context.fillText(this.icon, x, y); // show icon if there is no image
    }
 
    // Get local storage key used by the medal
    storageKey() { return medalsSaveName + '_' + this.id; }
}

// engine automatically renders medals
function medalsRender()
{
    if (!medalsDisplayQueue.length)
        return;
    
    // update first medal in queue
    const medal = medalsDisplayQueue[0];
    const time = timeReal - medalsDisplayTimeLast;
    if (!medalsDisplayTimeLast)
        medalsDisplayTimeLast = timeReal;
    else if (time > medalDisplayTime)
        medalsDisplayQueue.shift(medalsDisplayTimeLast = 0);
    else
    {
        // slide on/off medals
        const slideOffTime = medalDisplayTime - medalDisplaySlideTime;
        const hidePercent = 
            time &lt; medalDisplaySlideTime ? 1 - time / medalDisplaySlideTime :
            time > slideOffTime ? (time - slideOffTime) / medalDisplaySlideTime : 0;
        medal.render(hidePercent);
    }
}

///////////////////////////////////////////////////////////////////////////////

// global Newgrounds object
let newgrounds;

/** This can used to enable Newgrounds functionality
 *  @param {Number} app_id   - The newgrounds App ID
 *  @param {String} [cipher] - The encryption Key (AES-128/Base64)
 *  @memberof Medals */
function newgroundsInit(app_id, cipher) { newgrounds = new Newgrounds(app_id, cipher); }

/** 
 * Newgrounds API wrapper object
 * @example
 * // create a newgrounds object, replace the app id and cipher with your own
 * const app_id = '53123:1ZuSTQ9l';
 * const cipher = 'enF0vGH@Mj/FRASKL23Q==';
 * newgrounds = new Newgrounds(app_id, cipher);
 */
class Newgrounds
{
    /** Create a newgrounds object
     *  @param {Number} app_id   - The newgrounds App ID
     *  @param {String} [cipher] - The encryption Key (AES-128/Base64) */
    constructor(app_id, cipher)
    {
        ASSERT(!newgrounds &amp;&amp; app_id);
        this.app_id = app_id;
        this.cipher = cipher;
        this.host = location ? location.hostname : '';

        // create an instance of CryptoJS for encrypted calls
        cipher &amp;&amp; (this.cryptoJS = CryptoJS());

        // get session id from url search params
        const url = new URL(location.href);
        this.session_id = url.searchParams.get('ngio_session_id') || 0;

        if (this.session_id == 0)
            return; // only use newgrounds when logged in

        // get medals
        const medalsResult = this.call('Medal.getList');
        this.medals = medalsResult ? medalsResult.result.data['medals'] : [];
        debugMedals &amp;&amp; console.log(this.medals);
        for (const newgroundsMedal of this.medals)
        {
            const medal = medals[newgroundsMedal['id']];
            if (medal)
            {
                // copy newgrounds medal data
                medal.image.src =   newgroundsMedal['icon'];
                medal.name =        newgroundsMedal['name'];
                medal.description = newgroundsMedal['description'];
                medal.unlocked =    newgroundsMedal['unlocked'];
                medal.difficulty =  newgroundsMedal['difficulty'];
                medal.value =       newgroundsMedal['value'];

                if (medal.value)
                    medal.description = medal.description + ' (' + medal.value + ')';
            }
        }
    
        // get scoreboards
        const scoreboardResult = this.call('ScoreBoard.getBoards');
        this.scoreboards = scoreboardResult ? scoreboardResult.result.data.scoreboards : [];
        debugMedals &amp;&amp; console.log(this.scoreboards);

        const keepAliveMS = 5 * 60 * 1e3;
        setInterval(()=>this.call('Gateway.ping', 0, 1), keepAliveMS);
    }

    /** Send message to unlock a medal by id
     * @param {Number} id - The medal id */
    unlockMedal(id) { return this.call('Medal.unlock', {'id':id}, 1); }

    /** Send message to post score
     * @param {Number} id    - The scoreboard id
     * @param {Number} value - The score value */
    postScore(id, value) { return this.call('ScoreBoard.postScore', {'id':id, 'value':value}, 1); }

    /** Get scores from a scoreboard
     * @param {Number} id         - The scoreboard id
     * @param {String} [user=0]   - A user's id or name
     * @param {Number} [social=0] - If true, only social scores will be loaded
     * @param {Number} [skip=0]   - Number of scores to skip before start
     * @param {Number} [limit=10] - Number of scores to include in the list
     * @return {Object}           - The response JSON object
     */
    getScores(id, user=0, social=0, skip=0, limit=10)
    { return this.call('ScoreBoard.getScores', {'id':id, 'user':user, 'social':social, 'skip':skip, 'limit':limit}); }

    /** Send message to log a view */
    logView() { return this.call('App.logView', {'host':this.host}, 1); }

    /** Send a message to call a component of the Newgrounds API
     * @param {String}  component      - Name of the component
     * @param {Object}  [parameters=0] - Parameters to use for call
     * @param {Boolean} [async=0]      - If true, don't wait for response before continuing (avoid stall)
     * @return {Object}                - The response JSON object
     */
    call(component, parameters=0, async=0)
    {
        const call = {'component':component, 'parameters':parameters};
        if (this.cipher)
        {
            // encrypt using AES-128 Base64 with cryptoJS
            const cryptoJS = this.cryptoJS;
            const aesKey = cryptoJS['enc']['Base64']['parse'](this.cipher);
            const iv = cryptoJS['lib']['WordArray']['random'](16);
            const encrypted = cryptoJS['AES']['encrypt'](JSON.stringify(call), aesKey, {'iv':iv});
            call['secure'] = cryptoJS['enc']['Base64']['stringify'](iv.concat(encrypted['ciphertext']));
            call['parameters'] = 0;
        }

        // build the input object
        const input = 
        {
            'app_id':     this.app_id,
            'session_id': this.session_id,
            'call':       call
        };

        // build post data
        const formData = new FormData();
        formData.append('input', JSON.stringify(input));
        
        // send post data
        const xmlHttp = new XMLHttpRequest();
        const url = 'https://newgrounds.io/gateway_v3.php';
        xmlHttp.open('POST', url, !debugMedals &amp;&amp; async);
        xmlHttp.send(formData);
        debugMedals &amp;&amp; console.log(xmlHttp.responseText);
        return xmlHttp.responseText &amp;&amp; JSON.parse(xmlHttp.responseText);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Crypto-JS - https://github.com/brix/crypto-js [The MIT License (MIT)]
// Copyright (c) 2009-2013 Jeff Mott  Copyright (c) 2013-2016 Evan Vosberg

const CryptoJS=()=>eval(Function("[M='GBMGXz^oVYPPKKbB`agTXU|LxPc_ZBcMrZvCr~wyGfWrwk@ATqlqeTp^N?p{we}jIpEnB_sEr`l?YDkDhWhprc|Er|XETG?pTl`e}dIc[_N~}fzRycIfpW{HTolvoPB_FMe_eH~BTMx]yyOhv?biWPCGc]kABencBhgERHGf{OL`Dj`c^sh@canhy[secghiyotcdOWgO{tJIE^JtdGQRNSCrwKYciZOa]Y@tcRATYKzv|sXpboHcbCBf`}SKeXPFM|RiJsSNaIb]QPc[D]Jy_O^XkOVTZep`ONmntLL`Qz~UupHBX_Ia~WX]yTRJIxG`ioZ{fefLJFhdyYoyLPvqgH?b`[TMnTwwfzDXhfM?rKs^aFr|nyBdPmVHTtAjXoYUloEziWDCw_suyYT~lSMksI~ZNCS[Bex~j]Vz?kx`gdYSEMCsHpjbyxQvw|XxX_^nQYue{sBzVWQKYndtYQMWRef{bOHSfQhiNdtR{o?cUAHQAABThwHPT}F{VvFmgN`E@FiFYS`UJmpQNM`X|tPKHlccT}z}k{sACHL?Rt@MkWplxO`ASgh?hBsuuP|xD~LSH~KBlRs]t|l|_tQAroDRqWS^SEr[sYdPB}TAROtW{mIkE|dWOuLgLmJrucGLpebrAFKWjikTUzS|j}M}szasKOmrjy[?hpwnEfX[jGpLt@^v_eNwSQHNwtOtDgWD{rk|UgASs@mziIXrsHN_|hZuxXlPJOsA^^?QY^yGoCBx{ekLuZzRqQZdsNSx@ezDAn{XNj@fRXIwrDX?{ZQHwTEfu@GhxDOykqts|n{jOeZ@c`dvTY?e^]ATvWpb?SVyg]GC?SlzteilZJAL]mlhLjYZazY__qcVFYvt@|bIQnSno@OXyt]OulzkWqH`rYFWrwGs`v|~XeTsIssLrbmHZCYHiJrX}eEzSssH}]l]IhPQhPoQ}rCXLyhFIT[clhzYOvyHqigxmjz`phKUU^TPf[GRAIhNqSOdayFP@FmKmuIzMOeoqdpxyCOwCthcLq?n`L`tLIBboNn~uXeFcPE{C~mC`h]jUUUQe^`UqvzCutYCgct|SBrAeiYQW?X~KzCz}guXbsUw?pLsg@hDArw?KeJD[BN?GD@wgFWCiHq@Ypp_QKFixEKWqRp]oJFuVIEvjDcTFu~Zz]a{IcXhWuIdMQjJ]lwmGQ|]g~c]Hl]pl`Pd^?loIcsoNir_kikBYyg?NarXZEGYspt_vLBIoj}LI[uBFvm}tbqvC|xyR~a{kob|HlctZslTGtPDhBKsNsoZPuH`U`Fqg{gKnGSHVLJ^O`zmNgMn~{rsQuoymw^JY?iUBvw_~mMr|GrPHTERS[MiNpY[Mm{ggHpzRaJaoFomtdaQ_?xuTRm}@KjU~RtPsAdxa|uHmy}n^i||FVL[eQAPrWfLm^ndczgF~Nk~aplQvTUpHvnTya]kOenZlLAQIm{lPl@CCTchvCF[fI{^zPkeYZTiamoEcKmBMfZhk_j_~Fjp|wPVZlkh_nHu]@tP|hS@^G^PdsQ~f[RqgTDqezxNFcaO}HZhb|MMiNSYSAnQWCDJukT~e|OTgc}sf[cnr?fyzTa|EwEtRG|I~|IO}O]S|rp]CQ}}DWhSjC_|z|oY|FYl@WkCOoPuWuqr{fJu?Brs^_EBI[@_OCKs}?]O`jnDiXBvaIWhhMAQDNb{U`bqVR}oqVAvR@AZHEBY@depD]OLh`kf^UsHhzKT}CS}HQKy}Q~AeMydXPQztWSSzDnghULQgMAmbWIZ|lWWeEXrE^EeNoZApooEmrXe{NAnoDf`m}UNlRdqQ@jOc~HLOMWs]IDqJHYoMziEedGBPOxOb?[X`KxkFRg@`mgFYnP{hSaxwZfBQqTm}_?RSEaQga]w[vxc]hMne}VfSlqUeMo_iqmd`ilnJXnhdj^EEFifvZyxYFRf^VaqBhLyrGlk~qowqzHOBlOwtx?i{m~`n^G?Yxzxux}b{LSlx]dS~thO^lYE}bzKmUEzwW^{rPGhbEov[Plv??xtyKJshbG`KuO?hjBdS@Ru}iGpvFXJRrvOlrKN?`I_n_tplk}kgwSXuKylXbRQ]]?a|{xiT[li?k]CJpwy^o@ebyGQrPfF`aszGKp]baIx~H?ElETtFh]dz[OjGl@C?]VDhr}OE@V]wLTc[WErXacM{We`F|utKKjgllAxvsVYBZ@HcuMgLboFHVZmi}eIXAIFhS@A@FGRbjeoJWZ_NKd^oEH`qgy`q[Tq{x?LRP|GfBFFJV|fgZs`MLbpPYUdIV^]mD@FG]pYAT^A^RNCcXVrPsgk{jTrAIQPs_`mD}rOqAZA[}RETFz]WkXFTz_m{N@{W@_fPKZLT`@aIqf|L^Mb|crNqZ{BVsijzpGPEKQQZGlApDn`ruH}cvF|iXcNqK}cxe_U~HRnKV}sCYb`D~oGvwG[Ca|UaybXea~DdD~LiIbGRxJ_VGheI{ika}KC[OZJLn^IBkPrQj_EuoFwZ}DpoBRcK]Q}?EmTv~i_Tul{bky?Iit~tgS|o}JL_VYcCQdjeJ_MfaA`FgCgc[Ii|CBHwq~nbJeYTK{e`CNstKfTKPzw{jdhp|qsZyP_FcugxCFNpKitlR~vUrx^NrSVsSTaEgnxZTmKc`R|lGJeX}ccKLsQZQhsFkeFd|ckHIVTlGMg`~uPwuHRJS_CPuN_ogXe{Ba}dO_UBhuNXby|h?JlgBIqMKx^_u{molgL[W_iavNQuOq?ap]PGB`clAicnl@k~pA?MWHEZ{HuTLsCpOxxrKlBh]FyMjLdFl|nMIvTHyGAlPogqfZ?PlvlFJvYnDQd}R@uAhtJmDfe|iJqdkYr}r@mEjjIetDl_I`TELfoR|qTBu@Tic[BaXjP?dCS~MUK[HPRI}OUOwAaf|_}HZzrwXvbnNgltjTwkBE~MztTQhtRSWoQHajMoVyBBA`kdgK~h`o[J`dm~pm]tk@i`[F~F]DBlJKklrkR]SNw@{aG~Vhl`KINsQkOy?WhcqUMTGDOM_]bUjVd|Yh_KUCCgIJ|LDIGZCPls{RzbVWVLEhHvWBzKq|^N?DyJB|__aCUjoEgsARki}j@DQXS`RNU|DJ^a~d{sh_Iu{ONcUtSrGWW@cvUjefHHi}eSSGrNtO?cTPBShLqzwMVjWQQCCFB^culBjZHEK_{dO~Q`YhJYFn]jq~XSnG@[lQr]eKrjXpG~L^h~tDgEma^AUFThlaR{xyuP@[^VFwXSeUbVetufa@dX]CLyAnDV@Bs[DnpeghJw^?UIana}r_CKGDySoRudklbgio}kIDpA@McDoPK?iYcG?_zOmnWfJp}a[JLR[stXMo?_^Ng[whQlrDbrawZeSZ~SJstIObdDSfAA{MV}?gNunLOnbMv_~KFQUAjIMj^GkoGxuYtYbGDImEYiwEMyTpMxN_LSnSMdl{bg@dtAnAMvhDTBR_FxoQgANniRqxd`pWv@rFJ|mWNWmh[GMJz_Nq`BIN@KsjMPASXORcdHjf~rJfgZYe_uulzqM_KdPlMsuvU^YJuLtofPhGonVOQxCMuXliNvJIaoC?hSxcxKVVxWlNs^ENDvCtSmO~WxI[itnjs^RDvI@KqG}YekaSbTaB]ki]XM@[ZnDAP~@|BzLRgOzmjmPkRE@_sobkT|SszXK[rZN?F]Z_u}Yue^[BZgLtR}FHzWyxWEX^wXC]MJmiVbQuBzkgRcKGUhOvUc_bga|Tx`KEM`JWEgTpFYVeXLCm|mctZR@uKTDeUONPozBeIkrY`cz]]~WPGMUf`MNUGHDbxZuO{gmsKYkAGRPqjc|_FtblEOwy}dnwCHo]PJhN~JoteaJ?dmYZeB^Xd?X^pOKDbOMF@Ugg^hETLdhwlA}PL@_ur|o{VZosP?ntJ_kG][g{Zq`Tu]dzQlSWiKfnxDnk}KOzp~tdFstMobmy[oPYjyOtUzMWdjcNSUAjRuqhLS@AwB^{BFnqjCmmlk?jpn}TksS{KcKkDboXiwK]qMVjm~V`LgWhjS^nLGwfhAYrjDSBL_{cRus~{?xar_xqPlArrYFd?pHKdMEZzzjJpfC?Hv}mAuIDkyBxFpxhstTx`IO{rp}XGuQ]VtbHerlRc_LFGWK[XluFcNGUtDYMZny[M^nVKVeMllQI[xtvwQnXFlWYqxZZFp_|]^oWX[{pOMpxXxvkbyJA[DrPzwD|LW|QcV{Nw~U^dgguSpG]ClmO@j_TENIGjPWwgdVbHganhM?ema|dBaqla|WBd`poj~klxaasKxGG^xbWquAl~_lKWxUkDFagMnE{zHug{b`A~IYcQYBF_E}wiA}K@yxWHrZ{[d~|ARsYsjeNWzkMs~IOqqp[yzDE|WFrivsidTcnbHFRoW@XpAV`lv_zj?B~tPCppRjgbbDTALeFaOf?VcjnKTQMLyp{NwdylHCqmo?oelhjWuXj~}{fpuX`fra?GNkDiChYgVSh{R[BgF~eQa^WVz}ATI_CpY?g_diae]|ijH`TyNIF}|D_xpmBq_JpKih{Ba|sWzhnAoyraiDvk`h{qbBfsylBGmRH}DRPdryEsSaKS~tIaeF[s]I~xxHVrcNe@Jjxa@jlhZueLQqHh_]twVMqG_EGuwyab{nxOF?`HCle}nBZzlTQjkLmoXbXhOtBglFoMz?eqre`HiE@vNwBulglmQjj]DB@pPkPUgA^sjOAUNdSu_`oAzar?n?eMnw{{hYmslYi[TnlJD'",...']charCodeAtUinyxpf',"for(;e&lt;10359;c[e++]=p-=128,A=A?p-A&amp;&amp;A:p==34&amp;&amp;p)for(p=1;p&lt;128;y=f.map((n,x)=>(U=r[n]*2+1,U=Math.log(U/(h-U)),t-=a[x]*U,U/500)),t=~-h/(1+Math.exp(t))|1,i=o%h&lt;t,o=o%h+(i?t:h-t)*(o>>17)-!i*t,f.map((n,x)=>(U=r[n]+=(i*h/2-r[n]&lt;&lt;13)/((C[n]+=C[n]&lt;5)+1/20)>>13,a[x]+=y[x]*(i-t/h))),p=p*2+i)for(f='010202103203210431053105410642065206541'.split(t=0).map((n,x)=>(U=0,[...n].map((n,x)=>(U=U*997+(c[e-n]|0)|0)),h*32-1&amp;U*997+p+!!A*129)*12+x);o&lt;h*32;o=o*64|M.charCodeAt(d++)&amp;63);for(C=String.fromCharCode(...c);r=/[\0-#?@\\\\~]/.exec(C);)with(C.split(r))C=join(shift());return C")([],[],1&lt;&lt;17,[0,0,0,0,0,0,0,0,0,0,0,0],new Uint16Array(51e6).fill(1&lt;&lt;15),new Uint8Array(51e6),0,0,0,0));
/** 
 * LittleJS WebGL Interface
 * &lt;br> - All webgl used by the engine is wrapped up here
 * &lt;br> - For normal stuff you won't need to see or call anything in this file
 * &lt;br> - For advanced stuff there are helper functions to create shaders, textures, etc
 * &lt;br> - Can be disabled with glEnable to revert to 2D canvas rendering
 * &lt;br> - Batches sprite rendering on GPU for incredibly fast performance
 * &lt;br> - Sprite transform math is done in the shader where possible
 * @namespace WebGL
 */

'use strict';

/** The WebGL canvas which appears above the main canvas and below the overlay canvas
 *  @type {HTMLCanvasElement}
 *  @memberof WebGL */
let glCanvas;

/** 2d context for glCanvas 
 *  @type {WebGLRenderingContext}
 *  @memberof WebGL */
let glContext;

/** Main tile sheet texture automatically loaded by engine
 *  @type {WebGLTexture}
 *  @memberof WebGL */
let glTileTexture;

// WebGL internal variables not exposed to documentation
let glActiveTexture, glShader, glArrayBuffer, glVertexData, glPositionData, glColorData, glBatchCount, glBatchAdditive, glAdditive;

///////////////////////////////////////////////////////////////////////////////

// Init WebGL, called automatically by the engine
function glInit()
{
    // create the canvas and tile texture
    glCanvas = document.createElement('canvas');
    glContext = glCanvas.getContext('webgl', {antialias: false});
    glCanvas.style = styleCanvas;
    glTileTexture = glCreateTexture(tileImage);

    // some browsers are much faster without copying the gl buffer so we just overlay it instead
    glOverlay &amp;&amp; document.body.appendChild(glCanvas);

    // setup vertex and fragment shaders
    glShader = glCreateProgram(
        'precision highp float;'+     // use highp for better accuracy
        'uniform mat4 m;'+            // transform matrix
        'attribute vec2 p,t;'+        // position, uv
        'attribute vec4 c,a;'+        // color, additiveColor
        'varying vec2 v;'+            // return uv
        'varying vec4 d,e;'+          // return color, additiveColor
        'void main(){'+               // shader entry point
        'gl_Position=m*vec4(p,1,1);'+ // transform position
        'v=t;d=c;e=a;'+               // pass stuff to fragment shader
        '}'                           // end of shader
        ,
        'precision highp float;'+           // use highp for better accuracy
        'varying vec2 v;'+                  // uv
        'varying vec4 d,e;'+                // color, additiveColor
        'uniform sampler2D s;'+             // texture
        'void main(){'+                     // shader entry point
        'gl_FragColor=texture2D(s,v)*d+e;'+ // modulate texture by color plus additive
        '}'                                 // end of shader
    );

    // init buffers
    glVertexData = new ArrayBuffer(gl_MAX_BATCH * gl_VERTICES_PER_QUAD * gl_VERTEX_BYTE_STRIDE);
    glArrayBuffer = glContext.createBuffer();
    glPositionData = new Float32Array(glVertexData);
    glColorData = new Uint32Array(glVertexData);
    glBatchCount = 0;
}

/** Set the WebGl blend mode, normally you should call setBlendMode instead
 *  @param {Boolean} [additive=0]
 *  @memberof WebGL */
function glSetBlendMode(additive)
{
    // setup blending
    glAdditive = additive;
}

/** Set the WebGl texture, not normally necessary unless multiple tile sheets are used
 *  &lt;br> - This may also flush the gl buffer resulting in more draw calls and worse performance
 *  @param {WebGLTexture} [texture=glTileTexture]
 *  @memberof WebGL */
function glSetTexture(texture=glTileTexture)
{
    // must flush cache with the old texture to set a new one
    if (texture != glActiveTexture)
        glFlush();

    glContext.bindTexture(gl_TEXTURE_2D, glActiveTexture = texture);
}

/** Compile WebGL shader of the given type, will throw errors if in debug mode
 *  @param {String} source
 *  @param          type
 *  @return {WebGLShader}
 *  @memberof WebGL */
function glCompileShader(source, type)
{
    // build the shader
    const shader = glContext.createShader(type);
    glContext.shaderSource(shader, source);
    glContext.compileShader(shader);

    // check for errors
    if (debug &amp;&amp; !glContext.getShaderParameter(shader, gl_COMPILE_STATUS))
        throw glContext.getShaderInfoLog(shader);
    return shader;
}

/** Create WebGL program with given shaders
 *  @param {WebGLShader} vsSource
 *  @param {WebGLShader} fsSource
 *  @return {WebGLProgram}
 *  @memberof WebGL */
function glCreateProgram(vsSource, fsSource)
{
    // build the program
    const program = glContext.createProgram();
    glContext.attachShader(program, glCompileShader(vsSource, gl_VERTEX_SHADER));
    glContext.attachShader(program, glCompileShader(fsSource, gl_FRAGMENT_SHADER));
    glContext.linkProgram(program);

    // check for errors
    if (debug &amp;&amp; !glContext.getProgramParameter(program, gl_LINK_STATUS))
        throw glContext.getProgramInfoLog(program);
    return program;
}

/** Create WebGL texture from an image and set the texture settings
 *  @param {Image} image
 *  @return {WebGLTexture}
 *  @memberof WebGL */
function glCreateTexture(image)
{
    // build the texture
    const texture = glContext.createTexture();
    glContext.bindTexture(gl_TEXTURE_2D, texture);
    image &amp;&amp; image.width &amp;&amp; glContext.texImage2D(gl_TEXTURE_2D, 0, gl_RGBA, gl_RGBA, gl_UNSIGNED_BYTE, image);
        
    // use point filtering for pixelated rendering
    glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_MIN_FILTER, cavasPixelated ? gl_NEAREST : gl_LINEAR);
    glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_MAG_FILTER, cavasPixelated ? gl_NEAREST : gl_LINEAR);
    glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_WRAP_S, gl_CLAMP_TO_EDGE);
    glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_WRAP_T, gl_CLAMP_TO_EDGE);
    return texture;
}

// called automatically by engine before render
function glPreRender(width, height, cameraX, cameraY, cameraScale)
{
    // clear and set to same size as main canvas
    glContext.viewport(0, 0, glCanvas.width = width, glCanvas.height = height);
    glContext.clear(gl_COLOR_BUFFER_BIT);

    // set up the shader
    glContext.useProgram(glShader);
    glContext.activeTexture(gl_TEXTURE0);
    glContext.bindTexture(gl_TEXTURE_2D, glActiveTexture = glTileTexture);
    glContext.bindBuffer(gl_ARRAY_BUFFER, glArrayBuffer);
    glContext.bufferData(gl_ARRAY_BUFFER, glVertexData.byteLength, gl_DYNAMIC_DRAW);
    glSetBlendMode();
    
    // set vertex attributes
    let offset = 0;
    const initVertexAttribArray = (name, type, typeSize, size, normalize=0)=>
    {
        const location = glContext.getAttribLocation(glShader, name);
        glContext.enableVertexAttribArray(location);
        glContext.vertexAttribPointer(location, size, type, normalize, gl_VERTEX_BYTE_STRIDE, offset);
        offset += size*typeSize;
    }
    initVertexAttribArray('p', gl_FLOAT, 4, 2);            // position
    initVertexAttribArray('t', gl_FLOAT, 4, 2);            // texture coords
    initVertexAttribArray('c', gl_UNSIGNED_BYTE, 1, 4, 1); // color
    initVertexAttribArray('a', gl_UNSIGNED_BYTE, 1, 4, 1); // additiveColor

    // build the transform matrix
    const sx = 2 * cameraScale / width;
    const sy = 2 * cameraScale / height;
    glContext.uniformMatrix4fv(glContext.getUniformLocation(glShader, 'm'), 0,
        new Float32Array([
            sx, 0, 0, 0,
            0, sy, 0, 0,
            1, 1, -1, 1,
            -1-sx*cameraX, -1-sy*cameraY, 0, 0
        ])
    );
}

/** Draw all sprites and clear out the buffer, called automatically by the system whenever necessary
 *  @memberof WebGL */
function glFlush()
{
    if (!glBatchCount) return;

    const destBlend = glBatchAdditive ? gl_ONE : gl_ONE_MINUS_SRC_ALPHA;
    glContext.blendFuncSeparate(gl_SRC_ALPHA, destBlend, gl_ONE, destBlend);
    glContext.enable(gl_BLEND);

    // draw all the sprites in the batch and reset the buffer
    glContext.bufferSubData(gl_ARRAY_BUFFER, 0, 
        glPositionData.subarray(0, glBatchCount * gl_VERTICES_PER_QUAD * gl_INDICIES_PER_VERT));
    glContext.drawArrays(gl_TRIANGLES, 0, glBatchCount * gl_VERTICES_PER_QUAD);
    glBatchCount = 0;
    glBatchAdditive = glAdditive;
}

/** Draw any sprites still in the buffer, copy to main canvas and clear
 *  @param {CanvasRenderingContext2D} context
 *  @param {Boolean} [forceDraw=0]
 *  @memberof WebGL */
function glCopyToContext(context, forceDraw)
{
    if (!glBatchCount &amp;&amp; !forceDraw) return;
    
    glFlush();
    
    // do not draw in overlay mode because the canvas is visible
    if (!glOverlay || forceDraw)
        context.drawImage(glCanvas, 0, 0);
}

/** Add a sprite to the gl draw list, used by all gl draw functions
 *  @param x
 *  @param y
 *  @param sizeX
 *  @param sizeY
 *  @param angle
 *  @param uv0X
 *  @param uv0Y
 *  @param uv1X
 *  @param uv1Y
 *  @param [rgba=0xffffffff]
 *  @param [rgbaAdditive=0]
 *  @memberof WebGL */
function glDraw(x, y, sizeX, sizeY, angle, uv0X, uv0Y, uv1X, uv1Y, rgba=0xffffffff, rgbaAdditive=0)
{
    // flush if there is no room for more verts or if different blend mode
    if (glBatchCount == gl_MAX_BATCH || glBatchAdditive != glAdditive)
        glFlush();

    // prepare to create the verts from size and angle
    const c = Math.cos(angle)/2, s = Math.sin(angle)/2;
    const cx = c*sizeX, cy = c*sizeY, sx = s*sizeX, sy = s*sizeY;
        
    // setup 2 triangles to form a quad
    let offset = glBatchCount++ * gl_VERTICES_PER_QUAD * gl_INDICIES_PER_VERT;

    // vertex 0
    glPositionData[offset++] = x - cx - sy;
    glPositionData[offset++] = y - cy + sx;
    glPositionData[offset++] = uv0X; glPositionData[offset++] = uv1Y;
    glColorData[offset++]    = rgba; glColorData[offset++]    = rgbaAdditive;
    
    // vertex 1
    glPositionData[offset++] = x + cx + sy;
    glPositionData[offset++] = y + cy - sx;
    glPositionData[offset++] = uv1X; glPositionData[offset++] = uv0Y;
    glColorData[offset++]    = rgba; glColorData[offset++]    = rgbaAdditive;
    
    // vertex 2
    glPositionData[offset++] = x - cx + sy;
    glPositionData[offset++] = y + cy + sx;
    glPositionData[offset++] = uv0X; glPositionData[offset++] = uv0Y;
    glColorData[offset++]    = rgba; glColorData[offset++]    = rgbaAdditive;
    
    // vertex 0
    glPositionData[offset++] = x - cx - sy;      
    glPositionData[offset++] = y - cy + sx;  
    glPositionData[offset++] = uv0X; glPositionData[offset++] = uv1Y;
    glColorData[offset++]    = rgba; glColorData[offset++]    = rgbaAdditive;

    // vertex 3
    glPositionData[offset++] = x + cx - sy;
    glPositionData[offset++] = y - cy - sx;
    glPositionData[offset++] = uv1X; glPositionData[offset++] = uv1Y;
    glColorData[offset++]    = rgba; glColorData[offset++]    = rgbaAdditive;

    // vertex 1
    glPositionData[offset++] = x + cx + sy;
    glPositionData[offset++] = y + cy - sx;
    glPositionData[offset++] = uv1X; glPositionData[offset++] = uv0Y;
    glColorData[offset++]    = rgba; glColorData[offset++]    = rgbaAdditive;
}

///////////////////////////////////////////////////////////////////////////////
// post processing - can be enabled to pass other canvases through a final shader

let glPostShader, glPostArrayBuffer, glPostTexture;

/** Set up a post processing shader
 *  @param {String} shaderCode
 *  @memberof WebGL */
function glInitPostProcess(shaderCode)
{
    ASSERT(!glPostShader); // can only have 1 post effects shader

    if (!shaderCode) // default shader
        shaderCode = 'void mainImage(out vec4 c,vec2 p){c=texture2D(iChannel0,p/iResolution.xy);}';

    // create the shader
    glPostShader = glCreateProgram(
        'precision highp float;'+        // use highp for better accuracy
        'attribute vec2 p;'+             // position
        'void main(){'+                  // shader entry point
        'gl_Position=vec4(p,1,1);'+      // set position
        '}'                              // end of shader
        ,
        'precision highp float;'+        // use highp for better accuracy
        'uniform sampler2D iChannel0;'+  // input texture
        'uniform vec3 iResolution;'+     // size of output texture
        'uniform float iTime;'+          // time passed
        '\n' + shaderCode + '\n'+        // insert custom shader code
        'void main(){'+                  // shader entry point
        'mainImage(gl_FragColor,gl_FragCoord.xy);'+ // call post process function
        'gl_FragColor.a=1.;'+            // always use full alpha
        '}'                              // end of shader
    );

    // create buffer and texture
    glPostArrayBuffer = glContext.createBuffer();
    glPostTexture = glCreateTexture();

    // hide the original 2d canvas
    mainCanvas.style.visibility = 'hidden';
}

// Render the post processing shader, called automatically by the engine
function glRenderPostProcess()
{
    if (!glPostShader)
        return;
    
    // prepare to render post process shader
    const width = mainCanvas.width, height = mainCanvas.height;
    if (glEnable)
    {
        glFlush(); // clear out the buffer
        mainContext.drawImage(glCanvas, 0, 0); // copy to the main canvas
    }
    else
        glContext.viewport(0, 0, glCanvas.width = width, glCanvas.height = height); // set viewport

    // setup shader program to draw one triangle
    glContext.useProgram(glPostShader);
    glContext.disable(gl_BLEND);
    glContext.bindBuffer(gl_ARRAY_BUFFER, glPostArrayBuffer);
    glContext.bufferData(gl_ARRAY_BUFFER, new Float32Array([-3,1,1,-3,1,1]), gl_STATIC_DRAW);
    glContext.pixelStorei(gl_UNPACK_FLIP_Y_WEBGL, true);

    // set textures, pass in the 2d canvas and gl canvas in separate texture channels
    glContext.activeTexture(gl_TEXTURE0);
    glContext.bindTexture(gl_TEXTURE_2D, glPostTexture);
    glContext.texImage2D(gl_TEXTURE_2D, 0, gl_RGBA, gl_RGBA, gl_UNSIGNED_BYTE, mainCanvas);

    // set vertex position attribute
    const vertexByteStride = 8;
    const pLocation = glContext.getAttribLocation(glPostShader, 'p');
    glContext.enableVertexAttribArray(pLocation);
    glContext.vertexAttribPointer(pLocation, 2, gl_FLOAT, 0, vertexByteStride, 0);

    // set uniforms and draw
    const uniformLocation = (name)=>glContext.getUniformLocation(glPostShader, name);
    glContext.uniform1i(uniformLocation('iChannel0'), 0);
    glContext.uniform1f(uniformLocation('iTime'), time);
    glContext.uniform3f(uniformLocation('iResolution'), width, height, 1);
    glContext.drawArrays(gl_TRIANGLES, 0, 3);
}

///////////////////////////////////////////////////////////////////////////////
// store gl constants as integers so their name doesn't use space in minifed
const 
gl_ONE = 1,
gl_TRIANGLES = 4,
gl_SRC_ALPHA = 770,
gl_ONE_MINUS_SRC_ALPHA = 771,
gl_BLEND = 3042,
gl_TEXTURE_2D = 3553,
gl_UNSIGNED_BYTE = 5121,
gl_BYTE = 5120,
gl_FLOAT = 5126,
gl_RGBA = 6408,
gl_NEAREST = 9728,
gl_LINEAR = 9729,
gl_TEXTURE_MAG_FILTER = 10240,
gl_TEXTURE_MIN_FILTER = 10241,
gl_TEXTURE_WRAP_S = 10242,
gl_TEXTURE_WRAP_T = 10243,
gl_COLOR_BUFFER_BIT = 16384,
gl_CLAMP_TO_EDGE = 33071,
gl_TEXTURE0 = 33984,
gl_TEXTURE1 = 33985,
gl_ARRAY_BUFFER = 34962,
gl_STATIC_DRAW = 35044,
gl_DYNAMIC_DRAW = 35048,
gl_FRAGMENT_SHADER = 35632, 
gl_VERTEX_SHADER = 35633,
gl_COMPILE_STATUS = 35713,
gl_LINK_STATUS = 35714,
gl_UNPACK_FLIP_Y_WEBGL = 37440,

// constants for batch rendering
gl_VERTICES_PER_QUAD = 6,
gl_INDICIES_PER_VERT = 6,
gl_MAX_BATCH = 1&lt;&lt;16,
gl_VERTEX_BYTE_STRIDE = (4 * 2) * 2 + (4) * 2; // vec2 * 2 + (char * 4) * 2
/*
    LittleJS - The Tiny JavaScript Game Engine That Can!
    MIT License - Copyright 2021 Frank Force

    Engine Features
    - Object oriented system with base class engine object
    - Base class object handles update, physics, collision, rendering, etc
    - Engine helper classes and functions like Vector2, Color, and Timer
    - Super fast rendering system for tile sheets
    - Sound effects audio with zzfx and music with zzfxm
    - Input processing system with gamepad and touchscreen support
    - Tile layer rendering and collision system
    - Particle effect system
    - Medal system tracks and displays achievements
    - Debug tools and debug rendering system
    - Call engineInit() to start it up!
*/

'use strict';

/** Name of engine */
const engineName = 'LittleJS';

/** Version of engine */
const engineVersion = '1.4.5';

/** Frames per second to update objects
 *  @default */
const frameRate = 60;

/** How many seconds each frame lasts, engine uses a fixed time step
 *  @default 1/60 */
const timeDelta = 1/frameRate;

/** Array containing all engine objects */
let engineObjects = [];

/** Array containing only objects that are set to collide with other objects this frame (for optimization) */
let engineObjectsCollide = [];

/** Current update frame, used to calculate time */
let frame = 0;

/** Current engine time since start in seconds, derived from frame */
let time = 0;

/** Actual clock time since start in seconds (not affected by pause or frame rate clamping) */
let timeReal = 0;

/** Is the game paused? Causes time and objects to not be updated. */
let paused = 0;

// Engine internal variables not exposed to documentation
let frameTimeLastMS = 0, frameTimeBufferMS = 0, tileImageSize, tileImageFixBleed;

// Engine stat tracking, if showWatermark is true
let averageFPS, drawCount;

// css text used for elements created by engine
const styleBody = 'margin:0;overflow:hidden;background:#000';
const styleCanvas = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)';

///////////////////////////////////////////////////////////////////////////////

/** Start up LittleJS engine with your callback functions
 *  @param {Function} gameInit        - Called once after the engine starts up, setup the game
 *  @param {Function} gameUpdate      - Called every frame at 60 frames per second, handle input and update the game state
 *  @param {Function} gameUpdatePost  - Called after physics and objects are updated, setup camera and prepare for render
 *  @param {Function} gameRender      - Called before objects are rendered, draw any background effects that appear behind objects
 *  @param {Function} gameRenderPost  - Called after objects are rendered, draw effects or hud that appear above all objects
 *  @param {String} [tileImageSource] - Tile image to use, everything starts when the image is finished loading
 */
function engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost, tileImageSource)
{
    // init engine when tiles load or fail to load
    tileImage.onerror = tileImage.onload = ()=>
    {
        // save tile image info
        tileImageFixBleed = vec2(tileFixBleedScale).divide(tileImageSize = vec2(tileImage.width, tileImage.height));
        debug &amp;&amp; (tileImage.onload=()=>ASSERT(1)); // tile sheet can not reloaded

        // setup html
        document.body.style = styleBody;
        document.body.appendChild(mainCanvas = document.createElement('canvas'));
        mainContext = mainCanvas.getContext('2d');
        mainCanvas.style = styleCanvas;

        // init stuff and start engine
        debugInit();
        glEnable &amp;&amp; glInit();

        // create overlay canvas for hud to appear above gl canvas
        document.body.appendChild(overlayCanvas = document.createElement('canvas'));
        overlayContext = overlayCanvas.getContext('2d');
        overlayCanvas.style = styleCanvas;
        
        gameInit();
        touchGamepadCreate();
        engineUpdate();
    };

    // main update loop
    const engineUpdate = (frameTimeMS=0)=>
    {
        // update time keeping
        let frameTimeDeltaMS = frameTimeMS - frameTimeLastMS;
        frameTimeLastMS = frameTimeMS;
        if (debug || showWatermark)
            averageFPS = lerp(.05, averageFPS || 0, 1e3/(frameTimeDeltaMS||1));
        const debugSpeedUp   = debug &amp;&amp; keyIsDown(107); // +
        const debugSpeedDown = debug &amp;&amp; keyIsDown(109); // -
        if (debug)
            frameTimeDeltaMS *= debugSpeedUp ? 5 : debugSpeedDown ? .2 : 1; // +/- to speed/slow time
        timeReal += frameTimeDeltaMS / 1e3;
        frameTimeBufferMS += !paused * frameTimeDeltaMS;
        if (!debugSpeedUp)
            frameTimeBufferMS = min(frameTimeBufferMS, 50); // clamp incase of slow framerate

        if (canvasFixedSize.x)
        {
            // clear set fixed size
            overlayCanvas.width  = mainCanvas.width  = canvasFixedSize.x;
            overlayCanvas.height = mainCanvas.height = canvasFixedSize.y;
            
            // fit to window by adding space on top or bottom if necessary
            const aspect = innerWidth / innerHeight;
            const fixedAspect = mainCanvas.width / mainCanvas.height;
            mainCanvas.style.width  = overlayCanvas.style.width  = aspect &lt; fixedAspect ? '100%' : '';
            mainCanvas.style.height = overlayCanvas.style.height = aspect &lt; fixedAspect ? '' : '100%';
            if (glCanvas)
            {
                glCanvas.style.width  = mainCanvas.style.width;
                glCanvas.style.height = mainCanvas.style.height;
            }
        }
        else
        {
            // clear and set size to same as window
             overlayCanvas.width  = mainCanvas.width  = min(innerWidth,  canvasMaxSize.x);
             overlayCanvas.height = mainCanvas.height = min(innerHeight, canvasMaxSize.y);
        }
        
        // save canvas size
        mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);

        if (paused)
        {
            // do post update even when paused
            inputUpdate();
            debugUpdate();
            gameUpdatePost();
            inputUpdatePost();
        }
        else
        {
            // apply time delta smoothing, improves smoothness of framerate in some browsers
            let deltaSmooth = 0;
            if (frameTimeBufferMS &lt; 0 &amp;&amp; frameTimeBufferMS > -9)
            {
                // force an update each frame if time is close enough (not just a fast refresh rate)
                deltaSmooth = frameTimeBufferMS;
                frameTimeBufferMS = 0;
            }
            
            // update multiple frames if necessary in case of slow framerate
            for (;frameTimeBufferMS >= 0; frameTimeBufferMS -= 1e3 / frameRate)
            {
                // update game and objects
                inputUpdate();
                gameUpdate();
                engineObjectsUpdate();

                // do post update
                debugUpdate();
                gameUpdatePost();
                inputUpdatePost();
            }

            // add the time smoothing back in
            frameTimeBufferMS += deltaSmooth;
        }
        
        // render sort then render while removing destroyed objects
        enginePreRender();
        gameRender();
        engineObjects.sort((a,b)=> a.renderOrder - b.renderOrder);
        for (const o of engineObjects)
            o.destroyed || o.render();
        gameRenderPost();
        glRenderPostProcess();
        medalsRender();
        touchGamepadRender();
        debugRender();
        glEnable &amp;&amp; glCopyToContext(mainContext);

        if (showWatermark)
        {
            // update fps
            overlayContext.textAlign = 'right';
            overlayContext.textBaseline = 'top';
            overlayContext.font = '1em monospace';
            overlayContext.fillStyle = '#000';
            const text = engineName + ' ' + 'v' + engineVersion + ' / ' 
                + drawCount + ' / ' + engineObjects.length + ' / ' + averageFPS.toFixed(1)
                + ' ' + (glEnable ? 'GL' : '2D') ;
            overlayContext.fillText(text, mainCanvas.width-3, 3);
            overlayContext.fillStyle = '#fff';
            overlayContext.fillText(text, mainCanvas.width-2, 2);
            drawCount = 0;
        }

        requestAnimationFrame(engineUpdate);
    }

    // set tile image source to load the image and start the engine
    tileImageSource ? tileImage.src = tileImageSource : tileImage.onload();
}

// called by engine to setup render system
function enginePreRender()
{
    // save canvas size
    mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);

    // disable smoothing for pixel art
    mainContext.imageSmoothingEnabled = !cavasPixelated;

    // setup gl rendering if enabled
    glEnable &amp;&amp; glPreRender(mainCanvas.width, mainCanvas.height, cameraPos.x, cameraPos.y, cameraScale);
}

///////////////////////////////////////////////////////////////////////////////

/** Calls update on each engine object (recursively if child), removes destroyed objects, and updated time */
function engineObjectsUpdate()
{
    // get list of solid objects for physics optimzation
    engineObjectsCollide = engineObjects.filter(o=>o.collideSolidObjects);

    // recursive object update
    const updateObject = (o)=>
    {
        if (!o.destroyed)
        {
            o.update();
            for (const child of o.children)
                updateObject(child);
        }
    }
    for (const o of engineObjects)
        o.parent || updateObject(o);

    // remove destroyed objects
    engineObjects = engineObjects.filter(o=>!o.destroyed);

    // increment frame and update time
    time = ++frame / frameRate;
}

/** Destroy and remove all objects */
function engineObjectsDestroy()
{
    for (const o of engineObjects)
        o.parent || o.destroy();
    engineObjects = engineObjects.filter(o=>!o.destroyed);
}

/** Triggers a callback for each object within a given area
 *  @param {Vector2} [pos]                 - Center of test area
 *  @param {Number} [size]                 - Radius of circle if float, rectangle size if Vector2
 *  @param {Function} [callbackFunction]   - Calls this function on every object that passes the test
 *  @param {Array} [objects=engineObjects] - List of objects to check */
function engineObjectsCallback(pos, size, callbackFunction, objects=engineObjects)
{
    if (!pos) // all objects
    {
        for (const o of objects)
            callbackFunction(o);
    }
    else if (size.x != undefined)  // bounding box test
    {
        for (const o of objects)
            isOverlapping(pos, size, o.pos, o.size) &amp;&amp; callbackFunction(o);
    }
    else  // circle test
    {
        const sizeSquared = size*size;
        for (const o of objects)
            pos.distanceSquared(o.pos) &lt; sizeSquared &amp;&amp; callbackFunction(o);
    }
}

// This file contains exports neessary when LittleJS is used as a module

// setters for all variables that devs will need to modify
const setCameraPos =                    (v)=> cameraPos = v;
const setCameraScale =                  (v)=> cameraScale = v;
const setRandSeed =                     (v)=> randSeed = v;
const setCanvasMaxSize =                (v)=> canvasMaxSize = v;
const setCanvasFixedSize =              (v)=> canvasFixedSize = v;
const setCavasPixelated =               (v)=> cavasPixelated = v;
const setFontDefault =                  (v)=> fontDefault = v;
const setTileSizeDefault =              (v)=> tileSizeDefault = v;
const setTileFixBleedScale =            (v)=> tileFixBleedScale = v;
const setObjectDefaultSize =            (v)=> objectDefaultSize = v;
const setEnablePhysicsSolver =          (v)=> enablePhysicsSolver = v;
const setObjectDefaultMass =            (v)=> objectDefaultMass = v;
const setObjectDefaultDamping =         (v)=> objectDefaultDamping = v;
const setObjectDefaultAngleDamping =    (v)=> objectDefaultAngleDamping = v;
const setObjectDefaultElasticity =      (v)=> objectDefaultElasticity = v;
const setObjectDefaultFriction =        (v)=> objectDefaultFriction = v;
const setObjectMaxSpeed =               (v)=> objectMaxSpeed = v;
const setGravity =                      (v)=> gravity = v;
const setParticleEmitRateScale =        (v)=> particleEmitRateScale = v;
const setGlEnable =                     (v)=> glEnable = v;
const setGlOverlay =                    (v)=> glOverlay = v;
const setGamepadsEnable =               (v)=> gamepadsEnable = v;
const setGamepadDirectionEmulateStick = (v)=> gamepadDirectionEmulateStick = v;
const setInputWASDEmulateDirection =    (v)=> inputWASDEmulateDirection = v;
const setTouchGamepadEnable =           (v)=> touchGamepadEnable = v;
const setTouchGamepadAnalog =           (v)=> touchGamepadAnalog = v;
const setTouchGamepadSize =             (v)=> touchGamepadSize = v;
const setTouchGamepadAlpha =            (v)=> touchGamepadAlpha = v;
const setVibrateEnable =                (v)=> vibrateEnable = v;
const setSoundVolume =                  (v)=> soundVolume = v;
const setSoundEnable =                  (v)=> soundEnable = v;
const setSoundDefaultRange =            (v)=> soundDefaultRange = v;
const setSoundDefaultTaper =            (v)=> soundDefaultTaper = v;
const setMedalDisplayTime =             (v)=> medalDisplayTime = v;
const setMedalDisplaySlideTime =        (v)=> medalDisplaySlideTime = v;
const setMedalDisplayWidth =            (v)=> medalDisplayWidth = v;
const setMedalDisplayHeight =           (v)=> medalDisplayHeight = v;
const setMedalDisplayIconSize =         (v)=> medalDisplayIconSize = v;
const setMedalsPreventUnlock =          (v)=> medalsPreventUnlock = v;
const setDebugPointSize =               (v)=> debugPointSize = v;
const setShowWatermark =                (v)=> showWatermark = v;
const setGodMode =                      (v)=> godMode = v;

// This is a full list of everything in engine.all
export {
	// Custom methods
	setCameraPos,
	setCameraScale,
	setRandSeed,
	setCanvasMaxSize,
	setCanvasFixedSize,
	setCavasPixelated,
	setFontDefault,
	setTileSizeDefault,
	setTileFixBleedScale,
	setObjectDefaultSize,
	setEnablePhysicsSolver,
	setObjectDefaultMass,
	setObjectDefaultDamping,
	setObjectDefaultAngleDamping,
	setObjectDefaultElasticity,
	setObjectDefaultFriction,
	setObjectMaxSpeed,
	setGravity,
	setParticleEmitRateScale,
	setGlEnable,
	setGlOverlay,
	setGamepadsEnable,
	setGamepadDirectionEmulateStick,
	setInputWASDEmulateDirection,
	setTouchGamepadEnable,
	setTouchGamepadAnalog,
	setTouchGamepadSize,
	setTouchGamepadAlpha,
	setVibrateEnable,
	setSoundVolume,
	setSoundEnable,
	setSoundDefaultRange,
	setSoundDefaultTaper,
	setMedalDisplayTime,
	setMedalDisplaySlideTime,
	setMedalDisplayWidth,
	setMedalDisplayHeight,
	setMedalDisplayIconSize,
	setMedalsPreventUnlock,
	setDebugPointSize,
	setShowWatermark,
	setGodMode,

	// Settings
	canvasMaxSize,
	canvasFixedSize,
	cavasPixelated,
	fontDefault,
	tileSizeDefault,
	tileFixBleedScale,
	objectDefaultSize,
	enablePhysicsSolver,
	objectDefaultMass,
	objectDefaultDamping,
	objectDefaultAngleDamping,
	objectDefaultElasticity,
	objectDefaultFriction,
	objectMaxSpeed,
	gravity,
	particleEmitRateScale,
	cameraPos,
	cameraScale,
	glEnable,
	glOverlay,
	gamepadsEnable,
	gamepadDirectionEmulateStick,
	inputWASDEmulateDirection,
	touchGamepadEnable,
	touchGamepadAnalog,
	touchGamepadSize,
	touchGamepadAlpha,
	vibrateEnable,
	soundVolume,
	soundEnable,
	soundDefaultRange,
	soundDefaultTaper,
	medalDisplayTime,
	medalDisplaySlideTime,
	medalDisplayWidth,
	medalDisplayHeight,
	medalDisplayIconSize,
	
	// Globals
	debug,
	debugPointSize,
	showWatermark,
	godMode,
	// Debug
	//debugPrimitives,
	//debugOverlay,
	//debugPhysics,
	//debugRaycast,
	//debugParticles,
	//debugGamepads,
	//debugMedals,
	//debugTakeScreenshot,
	//downloadLink,
	//ASSERT,
	debugRect,
	debugCircle,
	debugPoint,
	debugLine,
	debugAABB,
	debugText,
	debugClear,
	debugSaveCanvas,
	//debugInit,
	//debugUpdate,
	//debugRender,

	// Utilities
	PI,
	abs,
	min,
	max,
	sign,
	mod,
	clamp,
	percent,
	lerp,
	smoothStep,
	nearestPowerOfTwo,
	isOverlapping,
	wave,
	formatTime,
	// Random
	rand,
	randInt,
	randSign,
	randInCircle,
	randVector,
	randColor,
	randSeed,
	randSeeded,

	// More utilities
	vec2,
	Vector2,
	colorRGBA,
	colorHSLA,
	Color,
	Timer,

	// Base
	EngineObject,

	// Draw
	tileImage,
	mainCanvas,
	mainContext,
	overlayCanvas,
	overlayContext,
	mainCanvasSize,
	screenToWorld,
	worldToScreen,
	drawTile,
	drawRect,
	drawTileScreenSpace,
	drawRectScreenSpace,
	drawLine,
	drawCanvas2D,
	setBlendMode,
	drawTextScreen,
	drawText,
	engineFontImage,
	FontImage,
	isFullscreen,
	toggleFullscreen,

	// Input
	keyIsDown,
	keyWasPressed,
	keyWasReleased,
	clearInput,
	mouseIsDown,
	mouseWasPressed,
	mouseWasReleased,
	mousePos,
	mousePosScreen,
	mouseWheel,
	isUsingGamepad,
	preventDefaultInput,
	gamepadIsDown,
	gamepadWasPressed,
	gamepadWasReleased,
	gamepadStick,
	//inputData,
	//inputUpdate,
	//inputUpdatePost,
	// onkeydown,
	// onkeyup,
	//remapKeyCode,
	// onmousedown,
	// onmouseup,
	// onmousemove,
	// onwheel,
	// oncontextmenu,
	mouseToScreen,
	//stickData,
	gamepadsUpdate,
	vibrate,
	vibrateStop,
	isTouchDevice,
	//touchGamepadTimer,
	touchGamepadCreate,
	touchGamepadRender,

	// Audio
	Sound,
	Music,
	playAudioFile,
	speak,
	speakStop,
	getNoteFrequency,
	audioContext,
	playSamples,
	zzfx,
	//zzfxR,
	//zzfxG,
	//zzfxM,

	// Tiles
	tileCollision,
	tileCollisionSize,
	initTileCollision,
	setTileCollisionData,
	getTileCollisionData,
	tileCollisionTest,
	tileCollisionRaycast,
	TileLayerData,
	TileLayer,

	// Particles
	ParticleEmitter,
	Particle,

	// Medals
	medals,
	medalsPreventUnlock,
	medalsInit,
	newgroundsInit,
	Medal,
	//medalsRender,
	Newgrounds,
	//CryptoJS,

	// WebGL
	glCanvas,
	glContext,
	//glInit,
	glSetBlendMode,
	glSetTexture,
	glCompileShader,
	glCreateProgram,
	glCreateTexture,
	//glPreRender,
	//glFlush,
	//glCopyToContext,
	//glDraw,
	glInitPostProcess,
	//glRenderPostProcess,

	// Engine
	engineName,
	engineVersion,
	frameRate,
	timeDelta,
	engineObjects,
	//engineObjectsCollide,
	frame,
	time,
	timeReal,
	paused,
	//frameTimeLastMS,
	//averageFPS,
	//drawCount,
	//styleBody,
	//styleCanvas,
	engineInit,
	//enginePreRender,
	//engineObjectsUpdate,
	engineObjectsDestroy,
	engineObjectsCallback,
};
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      <a href=https://github.com/KilledByAPixel/LittleJS>LittleJS - MIT License - Copyright 2021 Frank Force</a>
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Color","link":"<a href=\"Color.html\">Color</a>"},{"title":"Color#add","link":"<a href=\"Color.html#add\">Color &rtrif; add</a>"},{"title":"Color#add","link":"<a href=\"Color.html#add\">Color &rtrif; add</a>"},{"title":"Color#clamp","link":"<a href=\"Color.html#clamp\">Color &rtrif; clamp</a>"},{"title":"Color#clamp","link":"<a href=\"Color.html#clamp\">Color &rtrif; clamp</a>"},{"title":"Color#copy","link":"<a href=\"Color.html#copy\">Color &rtrif; copy</a>"},{"title":"Color#copy","link":"<a href=\"Color.html#copy\">Color &rtrif; copy</a>"},{"title":"Color#divide","link":"<a href=\"Color.html#divide\">Color &rtrif; divide</a>"},{"title":"Color#divide","link":"<a href=\"Color.html#divide\">Color &rtrif; divide</a>"},{"title":"Color#getHSLA","link":"<a href=\"Color.html#getHSLA\">Color &rtrif; getHSLA</a>"},{"title":"Color#getHSLA","link":"<a href=\"Color.html#getHSLA\">Color &rtrif; getHSLA</a>"},{"title":"Color#lerp","link":"<a href=\"Color.html#lerp\">Color &rtrif; lerp</a>"},{"title":"Color#lerp","link":"<a href=\"Color.html#lerp\">Color &rtrif; lerp</a>"},{"title":"Color#multiply","link":"<a href=\"Color.html#multiply\">Color &rtrif; multiply</a>"},{"title":"Color#multiply","link":"<a href=\"Color.html#multiply\">Color &rtrif; multiply</a>"},{"title":"Color#mutate","link":"<a href=\"Color.html#mutate\">Color &rtrif; mutate</a>"},{"title":"Color#mutate","link":"<a href=\"Color.html#mutate\">Color &rtrif; mutate</a>"},{"title":"Color#rgbaInt","link":"<a href=\"Color.html#rgbaInt\">Color &rtrif; rgbaInt</a>"},{"title":"Color#rgbaInt","link":"<a href=\"Color.html#rgbaInt\">Color &rtrif; rgbaInt</a>"},{"title":"Color#scale","link":"<a href=\"Color.html#scale\">Color &rtrif; scale</a>"},{"title":"Color#scale","link":"<a href=\"Color.html#scale\">Color &rtrif; scale</a>"},{"title":"Color#setHex","link":"<a href=\"Color.html#setHex\">Color &rtrif; setHex</a>"},{"title":"Color#setHex","link":"<a href=\"Color.html#setHex\">Color &rtrif; setHex</a>"},{"title":"Color#setHSLA","link":"<a href=\"Color.html#setHSLA\">Color &rtrif; setHSLA</a>"},{"title":"Color#setHSLA","link":"<a href=\"Color.html#setHSLA\">Color &rtrif; setHSLA</a>"},{"title":"Color#subtract","link":"<a href=\"Color.html#subtract\">Color &rtrif; subtract</a>"},{"title":"Color#subtract","link":"<a href=\"Color.html#subtract\">Color &rtrif; subtract</a>"},{"title":"Color#toString","link":"<a href=\"Color.html#toString\">Color &rtrif; toString</a>"},{"title":"Color#toString","link":"<a href=\"Color.html#toString\">Color &rtrif; toString</a>"},{"title":"EngineObject","link":"<a href=\"EngineObject.html\">EngineObject</a>"},{"title":"EngineObject#addChild","link":"<a href=\"EngineObject.html#addChild\">EngineObject &rtrif; addChild</a>"},{"title":"EngineObject#addChild","link":"<a href=\"EngineObject.html#addChild\">EngineObject &rtrif; addChild</a>"},{"title":"EngineObject#applyAcceleration","link":"<a href=\"EngineObject.html#applyAcceleration\">EngineObject &rtrif; applyAcceleration</a>"},{"title":"EngineObject#applyAcceleration","link":"<a href=\"EngineObject.html#applyAcceleration\">EngineObject &rtrif; applyAcceleration</a>"},{"title":"EngineObject#applyForce","link":"<a href=\"EngineObject.html#applyForce\">EngineObject &rtrif; applyForce</a>"},{"title":"EngineObject#applyForce","link":"<a href=\"EngineObject.html#applyForce\">EngineObject &rtrif; applyForce</a>"},{"title":"EngineObject#collideWithObject","link":"<a href=\"EngineObject.html#collideWithObject\">EngineObject &rtrif; collideWithObject</a>"},{"title":"EngineObject#collideWithObject","link":"<a href=\"EngineObject.html#collideWithObject\">EngineObject &rtrif; collideWithObject</a>"},{"title":"EngineObject#collideWithTile","link":"<a href=\"EngineObject.html#collideWithTile\">EngineObject &rtrif; collideWithTile</a>"},{"title":"EngineObject#collideWithTile","link":"<a href=\"EngineObject.html#collideWithTile\">EngineObject &rtrif; collideWithTile</a>"},{"title":"EngineObject#collideWithTileRaycast","link":"<a href=\"EngineObject.html#collideWithTileRaycast\">EngineObject &rtrif; collideWithTileRaycast</a>"},{"title":"EngineObject#collideWithTileRaycast","link":"<a href=\"EngineObject.html#collideWithTileRaycast\">EngineObject &rtrif; collideWithTileRaycast</a>"},{"title":"EngineObject#destroy","link":"<a href=\"EngineObject.html#destroy\">EngineObject &rtrif; destroy</a>"},{"title":"EngineObject#destroy","link":"<a href=\"EngineObject.html#destroy\">EngineObject &rtrif; destroy</a>"},{"title":"EngineObject#getAliveTime","link":"<a href=\"EngineObject.html#getAliveTime\">EngineObject &rtrif; getAliveTime</a>"},{"title":"EngineObject#getAliveTime","link":"<a href=\"EngineObject.html#getAliveTime\">EngineObject &rtrif; getAliveTime</a>"},{"title":"EngineObject#getMirrorSign","link":"<a href=\"EngineObject.html#getMirrorSign\">EngineObject &rtrif; getMirrorSign</a>"},{"title":"EngineObject#getMirrorSign","link":"<a href=\"EngineObject.html#getMirrorSign\">EngineObject &rtrif; getMirrorSign</a>"},{"title":"EngineObject#removeChild","link":"<a href=\"EngineObject.html#removeChild\">EngineObject &rtrif; removeChild</a>"},{"title":"EngineObject#removeChild","link":"<a href=\"EngineObject.html#removeChild\">EngineObject &rtrif; removeChild</a>"},{"title":"EngineObject#render","link":"<a href=\"EngineObject.html#render\">EngineObject &rtrif; render</a>"},{"title":"EngineObject#render","link":"<a href=\"EngineObject.html#render\">EngineObject &rtrif; render</a>"},{"title":"EngineObject#setCollision","link":"<a href=\"EngineObject.html#setCollision\">EngineObject &rtrif; setCollision</a>"},{"title":"EngineObject#setCollision","link":"<a href=\"EngineObject.html#setCollision\">EngineObject &rtrif; setCollision</a>"},{"title":"EngineObject#update","link":"<a href=\"EngineObject.html#update\">EngineObject &rtrif; update</a>"},{"title":"EngineObject#update","link":"<a href=\"EngineObject.html#update\">EngineObject &rtrif; update</a>"},{"title":"FontImage","link":"<a href=\"FontImage.html\">FontImage</a>"},{"title":"FontImage#drawText","link":"<a href=\"FontImage.html#drawText\">FontImage &rtrif; drawText</a>"},{"title":"FontImage#drawText","link":"<a href=\"FontImage.html#drawText\">FontImage &rtrif; drawText</a>"},{"title":"FontImage#drawTextScreen","link":"<a href=\"FontImage.html#drawTextScreen\">FontImage &rtrif; drawTextScreen</a>"},{"title":"FontImage#drawTextScreen","link":"<a href=\"FontImage.html#drawTextScreen\">FontImage &rtrif; drawTextScreen</a>"},{"title":"Medal","link":"<a href=\"Medal.html\">Medal</a>"},{"title":"Medal#render","link":"<a href=\"Medal.html#render\">Medal &rtrif; render</a>"},{"title":"Medal#render","link":"<a href=\"Medal.html#render\">Medal &rtrif; render</a>"},{"title":"Medal#renderIcon","link":"<a href=\"Medal.html#renderIcon\">Medal &rtrif; renderIcon</a>"},{"title":"Medal#renderIcon","link":"<a href=\"Medal.html#renderIcon\">Medal &rtrif; renderIcon</a>"},{"title":"Medal#unlock","link":"<a href=\"Medal.html#unlock\">Medal &rtrif; unlock</a>"},{"title":"Medal#unlock","link":"<a href=\"Medal.html#unlock\">Medal &rtrif; unlock</a>"},{"title":"Music","link":"<a href=\"Music.html\">Music</a>"},{"title":"Music#play","link":"<a href=\"Music.html#play\">Music &rtrif; play</a>"},{"title":"Music#play","link":"<a href=\"Music.html#play\">Music &rtrif; play</a>"},{"title":"Newgrounds","link":"<a href=\"Newgrounds.html\">Newgrounds</a>"},{"title":"Newgrounds#call","link":"<a href=\"Newgrounds.html#call\">Newgrounds &rtrif; call</a>"},{"title":"Newgrounds#call","link":"<a href=\"Newgrounds.html#call\">Newgrounds &rtrif; call</a>"},{"title":"Newgrounds#getScores","link":"<a href=\"Newgrounds.html#getScores\">Newgrounds &rtrif; getScores</a>"},{"title":"Newgrounds#getScores","link":"<a href=\"Newgrounds.html#getScores\">Newgrounds &rtrif; getScores</a>"},{"title":"Newgrounds#logView","link":"<a href=\"Newgrounds.html#logView\">Newgrounds &rtrif; logView</a>"},{"title":"Newgrounds#logView","link":"<a href=\"Newgrounds.html#logView\">Newgrounds &rtrif; logView</a>"},{"title":"Newgrounds#postScore","link":"<a href=\"Newgrounds.html#postScore\">Newgrounds &rtrif; postScore</a>"},{"title":"Newgrounds#postScore","link":"<a href=\"Newgrounds.html#postScore\">Newgrounds &rtrif; postScore</a>"},{"title":"Newgrounds#unlockMedal","link":"<a href=\"Newgrounds.html#unlockMedal\">Newgrounds &rtrif; unlockMedal</a>"},{"title":"Newgrounds#unlockMedal","link":"<a href=\"Newgrounds.html#unlockMedal\">Newgrounds &rtrif; unlockMedal</a>"},{"title":"Particle","link":"<a href=\"Particle.html\">Particle</a>"},{"title":"Particle#addChild","link":"<a href=\"Particle.html#addChild\">Particle &rtrif; addChild</a>"},{"title":"Particle#applyAcceleration","link":"<a href=\"Particle.html#applyAcceleration\">Particle &rtrif; applyAcceleration</a>"},{"title":"Particle#applyForce","link":"<a href=\"Particle.html#applyForce\">Particle &rtrif; applyForce</a>"},{"title":"Particle#collideWithObject","link":"<a href=\"Particle.html#collideWithObject\">Particle &rtrif; collideWithObject</a>"},{"title":"Particle#collideWithTile","link":"<a href=\"Particle.html#collideWithTile\">Particle &rtrif; collideWithTile</a>"},{"title":"Particle#collideWithTileRaycast","link":"<a href=\"Particle.html#collideWithTileRaycast\">Particle &rtrif; collideWithTileRaycast</a>"},{"title":"Particle#destroy","link":"<a href=\"Particle.html#destroy\">Particle &rtrif; destroy</a>"},{"title":"Particle#getAliveTime","link":"<a href=\"Particle.html#getAliveTime\">Particle &rtrif; getAliveTime</a>"},{"title":"Particle#getMirrorSign","link":"<a href=\"Particle.html#getMirrorSign\">Particle &rtrif; getMirrorSign</a>"},{"title":"Particle#removeChild","link":"<a href=\"Particle.html#removeChild\">Particle &rtrif; removeChild</a>"},{"title":"Particle#render","link":"<a href=\"Particle.html#render\">Particle &rtrif; render</a>"},{"title":"Particle#render","link":"<a href=\"Particle.html#render\">Particle &rtrif; render</a>"},{"title":"Particle#setCollision","link":"<a href=\"Particle.html#setCollision\">Particle &rtrif; setCollision</a>"},{"title":"Particle#update","link":"<a href=\"Particle.html#update\">Particle &rtrif; update</a>"},{"title":"ParticleEmitter","link":"<a href=\"ParticleEmitter.html\">ParticleEmitter</a>"},{"title":"ParticleEmitter#addChild","link":"<a href=\"ParticleEmitter.html#addChild\">ParticleEmitter &rtrif; addChild</a>"},{"title":"ParticleEmitter#applyAcceleration","link":"<a href=\"ParticleEmitter.html#applyAcceleration\">ParticleEmitter &rtrif; applyAcceleration</a>"},{"title":"ParticleEmitter#applyForce","link":"<a href=\"ParticleEmitter.html#applyForce\">ParticleEmitter &rtrif; applyForce</a>"},{"title":"ParticleEmitter#collideWithObject","link":"<a href=\"ParticleEmitter.html#collideWithObject\">ParticleEmitter &rtrif; collideWithObject</a>"},{"title":"ParticleEmitter#collideWithTile","link":"<a href=\"ParticleEmitter.html#collideWithTile\">ParticleEmitter &rtrif; collideWithTile</a>"},{"title":"ParticleEmitter#collideWithTileRaycast","link":"<a href=\"ParticleEmitter.html#collideWithTileRaycast\">ParticleEmitter &rtrif; collideWithTileRaycast</a>"},{"title":"ParticleEmitter#destroy","link":"<a href=\"ParticleEmitter.html#destroy\">ParticleEmitter &rtrif; destroy</a>"},{"title":"ParticleEmitter#emitParticle","link":"<a href=\"ParticleEmitter.html#emitParticle\">ParticleEmitter &rtrif; emitParticle</a>"},{"title":"ParticleEmitter#emitParticle","link":"<a href=\"ParticleEmitter.html#emitParticle\">ParticleEmitter &rtrif; emitParticle</a>"},{"title":"ParticleEmitter#getAliveTime","link":"<a href=\"ParticleEmitter.html#getAliveTime\">ParticleEmitter &rtrif; getAliveTime</a>"},{"title":"ParticleEmitter#getMirrorSign","link":"<a href=\"ParticleEmitter.html#getMirrorSign\">ParticleEmitter &rtrif; getMirrorSign</a>"},{"title":"ParticleEmitter#removeChild","link":"<a href=\"ParticleEmitter.html#removeChild\">ParticleEmitter &rtrif; removeChild</a>"},{"title":"ParticleEmitter#render","link":"<a href=\"ParticleEmitter.html#render\">ParticleEmitter &rtrif; render</a>"},{"title":"ParticleEmitter#setCollision","link":"<a href=\"ParticleEmitter.html#setCollision\">ParticleEmitter &rtrif; setCollision</a>"},{"title":"ParticleEmitter#update","link":"<a href=\"ParticleEmitter.html#update\">ParticleEmitter &rtrif; update</a>"},{"title":"ParticleEmitter#update","link":"<a href=\"ParticleEmitter.html#update\">ParticleEmitter &rtrif; update</a>"},{"title":"Sound","link":"<a href=\"Sound.html\">Sound</a>"},{"title":"Sound#play","link":"<a href=\"Sound.html#play\">Sound &rtrif; play</a>"},{"title":"Sound#play","link":"<a href=\"Sound.html#play\">Sound &rtrif; play</a>"},{"title":"Sound#playNote","link":"<a href=\"Sound.html#playNote\">Sound &rtrif; playNote</a>"},{"title":"Sound#playNote","link":"<a href=\"Sound.html#playNote\">Sound &rtrif; playNote</a>"},{"title":"TileLayer","link":"<a href=\"TileLayer.html\">TileLayer</a>"},{"title":"TileLayer#addChild","link":"<a href=\"TileLayer.html#addChild\">TileLayer &rtrif; addChild</a>"},{"title":"TileLayer#applyAcceleration","link":"<a href=\"TileLayer.html#applyAcceleration\">TileLayer &rtrif; applyAcceleration</a>"},{"title":"TileLayer#applyForce","link":"<a href=\"TileLayer.html#applyForce\">TileLayer &rtrif; applyForce</a>"},{"title":"TileLayer#collideWithObject","link":"<a href=\"TileLayer.html#collideWithObject\">TileLayer &rtrif; collideWithObject</a>"},{"title":"TileLayer#collideWithTile","link":"<a href=\"TileLayer.html#collideWithTile\">TileLayer &rtrif; collideWithTile</a>"},{"title":"TileLayer#collideWithTileRaycast","link":"<a href=\"TileLayer.html#collideWithTileRaycast\">TileLayer &rtrif; collideWithTileRaycast</a>"},{"title":"TileLayer#destroy","link":"<a href=\"TileLayer.html#destroy\">TileLayer &rtrif; destroy</a>"},{"title":"TileLayer#drawAllTileData","link":"<a href=\"TileLayer.html#drawAllTileData\">TileLayer &rtrif; drawAllTileData</a>"},{"title":"TileLayer#drawAllTileData","link":"<a href=\"TileLayer.html#drawAllTileData\">TileLayer &rtrif; drawAllTileData</a>"},{"title":"TileLayer#drawCanvas2D","link":"<a href=\"TileLayer.html#drawCanvas2D\">TileLayer &rtrif; drawCanvas2D</a>"},{"title":"TileLayer#drawCanvas2D","link":"<a href=\"TileLayer.html#drawCanvas2D\">TileLayer &rtrif; drawCanvas2D</a>"},{"title":"TileLayer#drawRect","link":"<a href=\"TileLayer.html#drawRect\">TileLayer &rtrif; drawRect</a>"},{"title":"TileLayer#drawRect","link":"<a href=\"TileLayer.html#drawRect\">TileLayer &rtrif; drawRect</a>"},{"title":"TileLayer#drawTile","link":"<a href=\"TileLayer.html#drawTile\">TileLayer &rtrif; drawTile</a>"},{"title":"TileLayer#drawTile","link":"<a href=\"TileLayer.html#drawTile\">TileLayer &rtrif; drawTile</a>"},{"title":"TileLayer#drawTileData","link":"<a href=\"TileLayer.html#drawTileData\">TileLayer &rtrif; drawTileData</a>"},{"title":"TileLayer#drawTileData","link":"<a href=\"TileLayer.html#drawTileData\">TileLayer &rtrif; drawTileData</a>"},{"title":"TileLayer#getAliveTime","link":"<a href=\"TileLayer.html#getAliveTime\">TileLayer &rtrif; getAliveTime</a>"},{"title":"TileLayer#getData","link":"<a href=\"TileLayer.html#getData\">TileLayer &rtrif; getData</a>"},{"title":"TileLayer#getData","link":"<a href=\"TileLayer.html#getData\">TileLayer &rtrif; getData</a>"},{"title":"TileLayer#getMirrorSign","link":"<a href=\"TileLayer.html#getMirrorSign\">TileLayer &rtrif; getMirrorSign</a>"},{"title":"TileLayer#redraw","link":"<a href=\"TileLayer.html#redraw\">TileLayer &rtrif; redraw</a>"},{"title":"TileLayer#redraw","link":"<a href=\"TileLayer.html#redraw\">TileLayer &rtrif; redraw</a>"},{"title":"TileLayer#redrawEnd","link":"<a href=\"TileLayer.html#redrawEnd\">TileLayer &rtrif; redrawEnd</a>"},{"title":"TileLayer#redrawEnd","link":"<a href=\"TileLayer.html#redrawEnd\">TileLayer &rtrif; redrawEnd</a>"},{"title":"TileLayer#redrawStart","link":"<a href=\"TileLayer.html#redrawStart\">TileLayer &rtrif; redrawStart</a>"},{"title":"TileLayer#redrawStart","link":"<a href=\"TileLayer.html#redrawStart\">TileLayer &rtrif; redrawStart</a>"},{"title":"TileLayer#removeChild","link":"<a href=\"TileLayer.html#removeChild\">TileLayer &rtrif; removeChild</a>"},{"title":"TileLayer#render","link":"<a href=\"TileLayer.html#render\">TileLayer &rtrif; render</a>"},{"title":"TileLayer#setCollision","link":"<a href=\"TileLayer.html#setCollision\">TileLayer &rtrif; setCollision</a>"},{"title":"TileLayer#setData","link":"<a href=\"TileLayer.html#setData\">TileLayer &rtrif; setData</a>"},{"title":"TileLayer#setData","link":"<a href=\"TileLayer.html#setData\">TileLayer &rtrif; setData</a>"},{"title":"TileLayer#update","link":"<a href=\"TileLayer.html#update\">TileLayer &rtrif; update</a>"},{"title":"TileLayerData","link":"<a href=\"TileLayerData.html\">TileLayerData</a>"},{"title":"TileLayerData#clear","link":"<a href=\"TileLayerData.html#clear\">TileLayerData &rtrif; clear</a>"},{"title":"TileLayerData#clear","link":"<a href=\"TileLayerData.html#clear\">TileLayerData &rtrif; clear</a>"},{"title":"Timer","link":"<a href=\"Timer.html\">Timer</a>"},{"title":"Timer#active","link":"<a href=\"Timer.html#active\">Timer &rtrif; active</a>"},{"title":"Timer#active","link":"<a href=\"Timer.html#active\">Timer &rtrif; active</a>"},{"title":"Timer#elapsed","link":"<a href=\"Timer.html#elapsed\">Timer &rtrif; elapsed</a>"},{"title":"Timer#elapsed","link":"<a href=\"Timer.html#elapsed\">Timer &rtrif; elapsed</a>"},{"title":"Timer#get","link":"<a href=\"Timer.html#get\">Timer &rtrif; get</a>"},{"title":"Timer#get","link":"<a href=\"Timer.html#get\">Timer &rtrif; get</a>"},{"title":"Timer#getPercent","link":"<a href=\"Timer.html#getPercent\">Timer &rtrif; getPercent</a>"},{"title":"Timer#getPercent","link":"<a href=\"Timer.html#getPercent\">Timer &rtrif; getPercent</a>"},{"title":"Timer#isSet","link":"<a href=\"Timer.html#isSet\">Timer &rtrif; isSet</a>"},{"title":"Timer#isSet","link":"<a href=\"Timer.html#isSet\">Timer &rtrif; isSet</a>"},{"title":"Timer#set","link":"<a href=\"Timer.html#set\">Timer &rtrif; set</a>"},{"title":"Timer#set","link":"<a href=\"Timer.html#set\">Timer &rtrif; set</a>"},{"title":"Timer#toString","link":"<a href=\"Timer.html#toString\">Timer &rtrif; toString</a>"},{"title":"Timer#toString","link":"<a href=\"Timer.html#toString\">Timer &rtrif; toString</a>"},{"title":"Timer#unset","link":"<a href=\"Timer.html#unset\">Timer &rtrif; unset</a>"},{"title":"Timer#unset","link":"<a href=\"Timer.html#unset\">Timer &rtrif; unset</a>"},{"title":"Timer#valueOf","link":"<a href=\"Timer.html#valueOf\">Timer &rtrif; valueOf</a>"},{"title":"Timer#valueOf","link":"<a href=\"Timer.html#valueOf\">Timer &rtrif; valueOf</a>"},{"title":"Vector2","link":"<a href=\"Vector2.html\">Vector2</a>"},{"title":"Vector2#add","link":"<a href=\"Vector2.html#add\">Vector2 &rtrif; add</a>"},{"title":"Vector2#add","link":"<a href=\"Vector2.html#add\">Vector2 &rtrif; add</a>"},{"title":"Vector2#angle","link":"<a href=\"Vector2.html#angle\">Vector2 &rtrif; angle</a>"},{"title":"Vector2#angle","link":"<a href=\"Vector2.html#angle\">Vector2 &rtrif; angle</a>"},{"title":"Vector2#area","link":"<a href=\"Vector2.html#area\">Vector2 &rtrif; area</a>"},{"title":"Vector2#area","link":"<a href=\"Vector2.html#area\">Vector2 &rtrif; area</a>"},{"title":"Vector2#arrayCheck","link":"<a href=\"Vector2.html#arrayCheck\">Vector2 &rtrif; arrayCheck</a>"},{"title":"Vector2#arrayCheck","link":"<a href=\"Vector2.html#arrayCheck\">Vector2 &rtrif; arrayCheck</a>"},{"title":"Vector2#clampLength","link":"<a href=\"Vector2.html#clampLength\">Vector2 &rtrif; clampLength</a>"},{"title":"Vector2#clampLength","link":"<a href=\"Vector2.html#clampLength\">Vector2 &rtrif; clampLength</a>"},{"title":"Vector2#copy","link":"<a href=\"Vector2.html#copy\">Vector2 &rtrif; copy</a>"},{"title":"Vector2#copy","link":"<a href=\"Vector2.html#copy\">Vector2 &rtrif; copy</a>"},{"title":"Vector2#cross","link":"<a href=\"Vector2.html#cross\">Vector2 &rtrif; cross</a>"},{"title":"Vector2#cross","link":"<a href=\"Vector2.html#cross\">Vector2 &rtrif; cross</a>"},{"title":"Vector2#direction","link":"<a href=\"Vector2.html#direction\">Vector2 &rtrif; direction</a>"},{"title":"Vector2#direction","link":"<a href=\"Vector2.html#direction\">Vector2 &rtrif; direction</a>"},{"title":"Vector2#distance","link":"<a href=\"Vector2.html#distance\">Vector2 &rtrif; distance</a>"},{"title":"Vector2#distance","link":"<a href=\"Vector2.html#distance\">Vector2 &rtrif; distance</a>"},{"title":"Vector2#distanceSquared","link":"<a href=\"Vector2.html#distanceSquared\">Vector2 &rtrif; distanceSquared</a>"},{"title":"Vector2#distanceSquared","link":"<a href=\"Vector2.html#distanceSquared\">Vector2 &rtrif; distanceSquared</a>"},{"title":"Vector2#divide","link":"<a href=\"Vector2.html#divide\">Vector2 &rtrif; divide</a>"},{"title":"Vector2#divide","link":"<a href=\"Vector2.html#divide\">Vector2 &rtrif; divide</a>"},{"title":"Vector2#dot","link":"<a href=\"Vector2.html#dot\">Vector2 &rtrif; dot</a>"},{"title":"Vector2#dot","link":"<a href=\"Vector2.html#dot\">Vector2 &rtrif; dot</a>"},{"title":"Vector2#floor","link":"<a href=\"Vector2.html#floor\">Vector2 &rtrif; floor</a>"},{"title":"Vector2#floor","link":"<a href=\"Vector2.html#floor\">Vector2 &rtrif; floor</a>"},{"title":"Vector2#invert","link":"<a href=\"Vector2.html#invert\">Vector2 &rtrif; invert</a>"},{"title":"Vector2#invert","link":"<a href=\"Vector2.html#invert\">Vector2 &rtrif; invert</a>"},{"title":"Vector2#length","link":"<a href=\"Vector2.html#length\">Vector2 &rtrif; length</a>"},{"title":"Vector2#length","link":"<a href=\"Vector2.html#length\">Vector2 &rtrif; length</a>"},{"title":"Vector2#lengthSquared","link":"<a href=\"Vector2.html#lengthSquared\">Vector2 &rtrif; lengthSquared</a>"},{"title":"Vector2#lengthSquared","link":"<a href=\"Vector2.html#lengthSquared\">Vector2 &rtrif; lengthSquared</a>"},{"title":"Vector2#lerp","link":"<a href=\"Vector2.html#lerp\">Vector2 &rtrif; lerp</a>"},{"title":"Vector2#lerp","link":"<a href=\"Vector2.html#lerp\">Vector2 &rtrif; lerp</a>"},{"title":"Vector2#multiply","link":"<a href=\"Vector2.html#multiply\">Vector2 &rtrif; multiply</a>"},{"title":"Vector2#multiply","link":"<a href=\"Vector2.html#multiply\">Vector2 &rtrif; multiply</a>"},{"title":"Vector2#normalize","link":"<a href=\"Vector2.html#normalize\">Vector2 &rtrif; normalize</a>"},{"title":"Vector2#normalize","link":"<a href=\"Vector2.html#normalize\">Vector2 &rtrif; normalize</a>"},{"title":"Vector2#rotate","link":"<a href=\"Vector2.html#rotate\">Vector2 &rtrif; rotate</a>"},{"title":"Vector2#rotate","link":"<a href=\"Vector2.html#rotate\">Vector2 &rtrif; rotate</a>"},{"title":"Vector2#scale","link":"<a href=\"Vector2.html#scale\">Vector2 &rtrif; scale</a>"},{"title":"Vector2#scale","link":"<a href=\"Vector2.html#scale\">Vector2 &rtrif; scale</a>"},{"title":"Vector2#setAngle","link":"<a href=\"Vector2.html#setAngle\">Vector2 &rtrif; setAngle</a>"},{"title":"Vector2#setAngle","link":"<a href=\"Vector2.html#setAngle\">Vector2 &rtrif; setAngle</a>"},{"title":"Vector2#subtract","link":"<a href=\"Vector2.html#subtract\">Vector2 &rtrif; subtract</a>"},{"title":"Vector2#subtract","link":"<a href=\"Vector2.html#subtract\">Vector2 &rtrif; subtract</a>"},{"title":"Vector2#toString","link":"<a href=\"Vector2.html#toString\">Vector2 &rtrif; toString</a>"},{"title":"Vector2#toString","link":"<a href=\"Vector2.html#toString\">Vector2 &rtrif; toString</a>"},{"title":"Debug","link":"<a href=\"Debug.html\">Debug</a>"},{"title":"Debug.debugAABB","link":"<a href=\"Debug.html#.debugAABB\">Debug &rtrif; debugAABB</a>"},{"title":"Debug.debugAABB","link":"<a href=\"Debug.html#.debugAABB\">Debug &rtrif; debugAABB</a>"},{"title":"Debug.debugCircle","link":"<a href=\"Debug.html#.debugCircle\">Debug &rtrif; debugCircle</a>"},{"title":"Debug.debugCircle","link":"<a href=\"Debug.html#.debugCircle\">Debug &rtrif; debugCircle</a>"},{"title":"Debug.debugClear","link":"<a href=\"Debug.html#.debugClear\">Debug &rtrif; debugClear</a>"},{"title":"Debug.debugClear","link":"<a href=\"Debug.html#.debugClear\">Debug &rtrif; debugClear</a>"},{"title":"Debug.debugLine","link":"<a href=\"Debug.html#.debugLine\">Debug &rtrif; debugLine</a>"},{"title":"Debug.debugLine","link":"<a href=\"Debug.html#.debugLine\">Debug &rtrif; debugLine</a>"},{"title":"Debug.debugPoint","link":"<a href=\"Debug.html#.debugPoint\">Debug &rtrif; debugPoint</a>"},{"title":"Debug.debugPoint","link":"<a href=\"Debug.html#.debugPoint\">Debug &rtrif; debugPoint</a>"},{"title":"Debug.debugRect","link":"<a href=\"Debug.html#.debugRect\">Debug &rtrif; debugRect</a>"},{"title":"Debug.debugRect","link":"<a href=\"Debug.html#.debugRect\">Debug &rtrif; debugRect</a>"},{"title":"Debug.debugSaveCanvas","link":"<a href=\"Debug.html#.debugSaveCanvas\">Debug &rtrif; debugSaveCanvas</a>"},{"title":"Debug.debugSaveCanvas","link":"<a href=\"Debug.html#.debugSaveCanvas\">Debug &rtrif; debugSaveCanvas</a>"},{"title":"Debug.debugText","link":"<a href=\"Debug.html#.debugText\">Debug &rtrif; debugText</a>"},{"title":"Debug.debugText","link":"<a href=\"Debug.html#.debugText\">Debug &rtrif; debugText</a>"},{"title":"Draw","link":"<a href=\"Draw.html\">Draw</a>"},{"title":"Draw.drawCanvas2D","link":"<a href=\"Draw.html#.drawCanvas2D\">Draw &rtrif; drawCanvas2D</a>"},{"title":"Draw.drawCanvas2D","link":"<a href=\"Draw.html#.drawCanvas2D\">Draw &rtrif; drawCanvas2D</a>"},{"title":"Draw.drawLine","link":"<a href=\"Draw.html#.drawLine\">Draw &rtrif; drawLine</a>"},{"title":"Draw.drawLine","link":"<a href=\"Draw.html#.drawLine\">Draw &rtrif; drawLine</a>"},{"title":"Draw.drawRect","link":"<a href=\"Draw.html#.drawRect\">Draw &rtrif; drawRect</a>"},{"title":"Draw.drawRect","link":"<a href=\"Draw.html#.drawRect\">Draw &rtrif; drawRect</a>"},{"title":"Draw.drawRectScreenSpace","link":"<a href=\"Draw.html#.drawRectScreenSpace\">Draw &rtrif; drawRectScreenSpace</a>"},{"title":"Draw.drawRectScreenSpace","link":"<a href=\"Draw.html#.drawRectScreenSpace\">Draw &rtrif; drawRectScreenSpace</a>"},{"title":"Draw.drawText","link":"<a href=\"Draw.html#.drawText\">Draw &rtrif; drawText</a>"},{"title":"Draw.drawText","link":"<a href=\"Draw.html#.drawText\">Draw &rtrif; drawText</a>"},{"title":"Draw.drawTextScreen","link":"<a href=\"Draw.html#.drawTextScreen\">Draw &rtrif; drawTextScreen</a>"},{"title":"Draw.drawTextScreen","link":"<a href=\"Draw.html#.drawTextScreen\">Draw &rtrif; drawTextScreen</a>"},{"title":"Draw.drawTile","link":"<a href=\"Draw.html#.drawTile\">Draw &rtrif; drawTile</a>"},{"title":"Draw.drawTile","link":"<a href=\"Draw.html#.drawTile\">Draw &rtrif; drawTile</a>"},{"title":"Draw.drawTileScreenSpace","link":"<a href=\"Draw.html#.drawTileScreenSpace\">Draw &rtrif; drawTileScreenSpace</a>"},{"title":"Draw.drawTileScreenSpace","link":"<a href=\"Draw.html#.drawTileScreenSpace\">Draw &rtrif; drawTileScreenSpace</a>"},{"title":"Draw.isFullscreen","link":"<a href=\"Draw.html#.isFullscreen\">Draw &rtrif; isFullscreen</a>"},{"title":"Draw.isFullscreen","link":"<a href=\"Draw.html#.isFullscreen\">Draw &rtrif; isFullscreen</a>"},{"title":"Draw.screenToWorld","link":"<a href=\"Draw.html#.screenToWorld\">Draw &rtrif; screenToWorld</a>"},{"title":"Draw.screenToWorld","link":"<a href=\"Draw.html#.screenToWorld\">Draw &rtrif; screenToWorld</a>"},{"title":"Draw.setBlendMode","link":"<a href=\"Draw.html#.setBlendMode\">Draw &rtrif; setBlendMode</a>"},{"title":"Draw.setBlendMode","link":"<a href=\"Draw.html#.setBlendMode\">Draw &rtrif; setBlendMode</a>"},{"title":"Draw.toggleFullscreen","link":"<a href=\"Draw.html#.toggleFullscreen\">Draw &rtrif; toggleFullscreen</a>"},{"title":"Draw.toggleFullscreen","link":"<a href=\"Draw.html#.toggleFullscreen\">Draw &rtrif; toggleFullscreen</a>"},{"title":"Draw.worldToScreen","link":"<a href=\"Draw.html#.worldToScreen\">Draw &rtrif; worldToScreen</a>"},{"title":"Draw.worldToScreen","link":"<a href=\"Draw.html#.worldToScreen\">Draw &rtrif; worldToScreen</a>"},{"title":"Input","link":"<a href=\"Input.html\">Input</a>"},{"title":"Input.clearInput","link":"<a href=\"Input.html#.clearInput\">Input &rtrif; clearInput</a>"},{"title":"Input.clearInput","link":"<a href=\"Input.html#.clearInput\">Input &rtrif; clearInput</a>"},{"title":"Input.gamepadIsDown","link":"<a href=\"Input.html#.gamepadIsDown\">Input &rtrif; gamepadIsDown</a>"},{"title":"Input.gamepadIsDown","link":"<a href=\"Input.html#.gamepadIsDown\">Input &rtrif; gamepadIsDown</a>"},{"title":"Input.gamepadStick","link":"<a href=\"Input.html#.gamepadStick\">Input &rtrif; gamepadStick</a>"},{"title":"Input.gamepadStick","link":"<a href=\"Input.html#.gamepadStick\">Input &rtrif; gamepadStick</a>"},{"title":"Input.gamepadWasPressed","link":"<a href=\"Input.html#.gamepadWasPressed\">Input &rtrif; gamepadWasPressed</a>"},{"title":"Input.gamepadWasPressed","link":"<a href=\"Input.html#.gamepadWasPressed\">Input &rtrif; gamepadWasPressed</a>"},{"title":"Input.gamepadWasReleased","link":"<a href=\"Input.html#.gamepadWasReleased\">Input &rtrif; gamepadWasReleased</a>"},{"title":"Input.gamepadWasReleased","link":"<a href=\"Input.html#.gamepadWasReleased\">Input &rtrif; gamepadWasReleased</a>"},{"title":"Input.keyIsDown","link":"<a href=\"Input.html#.keyIsDown\">Input &rtrif; keyIsDown</a>"},{"title":"Input.keyIsDown","link":"<a href=\"Input.html#.keyIsDown\">Input &rtrif; keyIsDown</a>"},{"title":"Input.keyWasPressed","link":"<a href=\"Input.html#.keyWasPressed\">Input &rtrif; keyWasPressed</a>"},{"title":"Input.keyWasPressed","link":"<a href=\"Input.html#.keyWasPressed\">Input &rtrif; keyWasPressed</a>"},{"title":"Input.keyWasReleased","link":"<a href=\"Input.html#.keyWasReleased\">Input &rtrif; keyWasReleased</a>"},{"title":"Input.keyWasReleased","link":"<a href=\"Input.html#.keyWasReleased\">Input &rtrif; keyWasReleased</a>"},{"title":"Input.vibrate","link":"<a href=\"Input.html#.vibrate\">Input &rtrif; vibrate</a>"},{"title":"Input.vibrate","link":"<a href=\"Input.html#.vibrate\">Input &rtrif; vibrate</a>"},{"title":"Input.vibrateStop","link":"<a href=\"Input.html#.vibrateStop\">Input &rtrif; vibrateStop</a>"},{"title":"Input.vibrateStop","link":"<a href=\"Input.html#.vibrateStop\">Input &rtrif; vibrateStop</a>"},{"title":"Medals","link":"<a href=\"Medals.html\">Medals</a>"},{"title":"Medals.medalsInit","link":"<a href=\"Medals.html#.medalsInit\">Medals &rtrif; medalsInit</a>"},{"title":"Medals.medalsInit","link":"<a href=\"Medals.html#.medalsInit\">Medals &rtrif; medalsInit</a>"},{"title":"Medals.newgroundsInit","link":"<a href=\"Medals.html#.newgroundsInit\">Medals &rtrif; newgroundsInit</a>"},{"title":"Medals.newgroundsInit","link":"<a href=\"Medals.html#.newgroundsInit\">Medals &rtrif; newgroundsInit</a>"},{"title":"Random","link":"<a href=\"Random.html\">Random</a>"},{"title":"Random.rand","link":"<a href=\"Random.html#.rand\">Random &rtrif; rand</a>"},{"title":"Random.rand","link":"<a href=\"Random.html#.rand\">Random &rtrif; rand</a>"},{"title":"Random.randColor","link":"<a href=\"Random.html#.randColor\">Random &rtrif; randColor</a>"},{"title":"Random.randColor","link":"<a href=\"Random.html#.randColor\">Random &rtrif; randColor</a>"},{"title":"Random.randInCircle","link":"<a href=\"Random.html#.randInCircle\">Random &rtrif; randInCircle</a>"},{"title":"Random.randInCircle","link":"<a href=\"Random.html#.randInCircle\">Random &rtrif; randInCircle</a>"},{"title":"Random.randInt","link":"<a href=\"Random.html#.randInt\">Random &rtrif; randInt</a>"},{"title":"Random.randInt","link":"<a href=\"Random.html#.randInt\">Random &rtrif; randInt</a>"},{"title":"Random.randSeeded","link":"<a href=\"Random.html#.randSeeded\">Random &rtrif; randSeeded</a>"},{"title":"Random.randSeeded","link":"<a href=\"Random.html#.randSeeded\">Random &rtrif; randSeeded</a>"},{"title":"Random.randSign","link":"<a href=\"Random.html#.randSign\">Random &rtrif; randSign</a>"},{"title":"Random.randSign","link":"<a href=\"Random.html#.randSign\">Random &rtrif; randSign</a>"},{"title":"Random.randVector","link":"<a href=\"Random.html#.randVector\">Random &rtrif; randVector</a>"},{"title":"Random.randVector","link":"<a href=\"Random.html#.randVector\">Random &rtrif; randVector</a>"},{"title":"Settings","link":"<a href=\"Settings.html\">Settings</a>"},{"title":"TileCollision","link":"<a href=\"TileCollision.html\">TileCollision</a>"},{"title":"TileCollision.getTileCollisionData","link":"<a href=\"TileCollision.html#.getTileCollisionData\">TileCollision &rtrif; getTileCollisionData</a>"},{"title":"TileCollision.getTileCollisionData","link":"<a href=\"TileCollision.html#.getTileCollisionData\">TileCollision &rtrif; getTileCollisionData</a>"},{"title":"TileCollision.initTileCollision","link":"<a href=\"TileCollision.html#.initTileCollision\">TileCollision &rtrif; initTileCollision</a>"},{"title":"TileCollision.initTileCollision","link":"<a href=\"TileCollision.html#.initTileCollision\">TileCollision &rtrif; initTileCollision</a>"},{"title":"TileCollision.setTileCollisionData","link":"<a href=\"TileCollision.html#.setTileCollisionData\">TileCollision &rtrif; setTileCollisionData</a>"},{"title":"TileCollision.setTileCollisionData","link":"<a href=\"TileCollision.html#.setTileCollisionData\">TileCollision &rtrif; setTileCollisionData</a>"},{"title":"TileCollision.tileCollisionRaycast","link":"<a href=\"TileCollision.html#.tileCollisionRaycast\">TileCollision &rtrif; tileCollisionRaycast</a>"},{"title":"TileCollision.tileCollisionRaycast","link":"<a href=\"TileCollision.html#.tileCollisionRaycast\">TileCollision &rtrif; tileCollisionRaycast</a>"},{"title":"TileCollision.tileCollisionTest","link":"<a href=\"TileCollision.html#.tileCollisionTest\">TileCollision &rtrif; tileCollisionTest</a>"},{"title":"TileCollision.tileCollisionTest","link":"<a href=\"TileCollision.html#.tileCollisionTest\">TileCollision &rtrif; tileCollisionTest</a>"},{"title":"Utilities","link":"<a href=\"Utilities.html\">Utilities</a>"},{"title":"Utilities.abs","link":"<a href=\"Utilities.html#.abs\">Utilities &rtrif; abs</a>"},{"title":"Utilities.abs","link":"<a href=\"Utilities.html#.abs\">Utilities &rtrif; abs</a>"},{"title":"Utilities.clamp","link":"<a href=\"Utilities.html#.clamp\">Utilities &rtrif; clamp</a>"},{"title":"Utilities.clamp","link":"<a href=\"Utilities.html#.clamp\">Utilities &rtrif; clamp</a>"},{"title":"Utilities.colorHSLA","link":"<a href=\"Utilities.html#.colorHSLA\">Utilities &rtrif; colorHSLA</a>"},{"title":"Utilities.colorHSLA","link":"<a href=\"Utilities.html#.colorHSLA\">Utilities &rtrif; colorHSLA</a>"},{"title":"Utilities.colorRGBA","link":"<a href=\"Utilities.html#.colorRGBA\">Utilities &rtrif; colorRGBA</a>"},{"title":"Utilities.colorRGBA","link":"<a href=\"Utilities.html#.colorRGBA\">Utilities &rtrif; colorRGBA</a>"},{"title":"Utilities.formatTime","link":"<a href=\"Utilities.html#.formatTime\">Utilities &rtrif; formatTime</a>"},{"title":"Utilities.formatTime","link":"<a href=\"Utilities.html#.formatTime\">Utilities &rtrif; formatTime</a>"},{"title":"Utilities.isOverlapping","link":"<a href=\"Utilities.html#.isOverlapping\">Utilities &rtrif; isOverlapping</a>"},{"title":"Utilities.isOverlapping","link":"<a href=\"Utilities.html#.isOverlapping\">Utilities &rtrif; isOverlapping</a>"},{"title":"Utilities.lerp","link":"<a href=\"Utilities.html#.lerp\">Utilities &rtrif; lerp</a>"},{"title":"Utilities.lerp","link":"<a href=\"Utilities.html#.lerp\">Utilities &rtrif; lerp</a>"},{"title":"Utilities.max","link":"<a href=\"Utilities.html#.max\">Utilities &rtrif; max</a>"},{"title":"Utilities.max","link":"<a href=\"Utilities.html#.max\">Utilities &rtrif; max</a>"},{"title":"Utilities.min","link":"<a href=\"Utilities.html#.min\">Utilities &rtrif; min</a>"},{"title":"Utilities.min","link":"<a href=\"Utilities.html#.min\">Utilities &rtrif; min</a>"},{"title":"Utilities.mod","link":"<a href=\"Utilities.html#.mod\">Utilities &rtrif; mod</a>"},{"title":"Utilities.mod","link":"<a href=\"Utilities.html#.mod\">Utilities &rtrif; mod</a>"},{"title":"Utilities.nearestPowerOfTwo","link":"<a href=\"Utilities.html#.nearestPowerOfTwo\">Utilities &rtrif; nearestPowerOfTwo</a>"},{"title":"Utilities.nearestPowerOfTwo","link":"<a href=\"Utilities.html#.nearestPowerOfTwo\">Utilities &rtrif; nearestPowerOfTwo</a>"},{"title":"Utilities.percent","link":"<a href=\"Utilities.html#.percent\">Utilities &rtrif; percent</a>"},{"title":"Utilities.percent","link":"<a href=\"Utilities.html#.percent\">Utilities &rtrif; percent</a>"},{"title":"Utilities.sign","link":"<a href=\"Utilities.html#.sign\">Utilities &rtrif; sign</a>"},{"title":"Utilities.sign","link":"<a href=\"Utilities.html#.sign\">Utilities &rtrif; sign</a>"},{"title":"Utilities.smoothStep","link":"<a href=\"Utilities.html#.smoothStep\">Utilities &rtrif; smoothStep</a>"},{"title":"Utilities.smoothStep","link":"<a href=\"Utilities.html#.smoothStep\">Utilities &rtrif; smoothStep</a>"},{"title":"Utilities.vec2","link":"<a href=\"Utilities.html#.vec2\">Utilities &rtrif; vec2</a>"},{"title":"Utilities.vec2","link":"<a href=\"Utilities.html#.vec2\">Utilities &rtrif; vec2</a>"},{"title":"Utilities.wave","link":"<a href=\"Utilities.html#.wave\">Utilities &rtrif; wave</a>"},{"title":"Utilities.wave","link":"<a href=\"Utilities.html#.wave\">Utilities &rtrif; wave</a>"},{"title":"WebGL","link":"<a href=\"WebGL.html\">WebGL</a>"},{"title":"WebGL.glCompileShader","link":"<a href=\"WebGL.html#.glCompileShader\">WebGL &rtrif; glCompileShader</a>"},{"title":"WebGL.glCompileShader","link":"<a href=\"WebGL.html#.glCompileShader\">WebGL &rtrif; glCompileShader</a>"},{"title":"WebGL.glCopyToContext","link":"<a href=\"WebGL.html#.glCopyToContext\">WebGL &rtrif; glCopyToContext</a>"},{"title":"WebGL.glCopyToContext","link":"<a href=\"WebGL.html#.glCopyToContext\">WebGL &rtrif; glCopyToContext</a>"},{"title":"WebGL.glCreateProgram","link":"<a href=\"WebGL.html#.glCreateProgram\">WebGL &rtrif; glCreateProgram</a>"},{"title":"WebGL.glCreateProgram","link":"<a href=\"WebGL.html#.glCreateProgram\">WebGL &rtrif; glCreateProgram</a>"},{"title":"WebGL.glCreateTexture","link":"<a href=\"WebGL.html#.glCreateTexture\">WebGL &rtrif; glCreateTexture</a>"},{"title":"WebGL.glCreateTexture","link":"<a href=\"WebGL.html#.glCreateTexture\">WebGL &rtrif; glCreateTexture</a>"},{"title":"WebGL.glDraw","link":"<a href=\"WebGL.html#.glDraw\">WebGL &rtrif; glDraw</a>"},{"title":"WebGL.glDraw","link":"<a href=\"WebGL.html#.glDraw\">WebGL &rtrif; glDraw</a>"},{"title":"WebGL.glFlush","link":"<a href=\"WebGL.html#.glFlush\">WebGL &rtrif; glFlush</a>"},{"title":"WebGL.glFlush","link":"<a href=\"WebGL.html#.glFlush\">WebGL &rtrif; glFlush</a>"},{"title":"WebGL.glInitPostProcess","link":"<a href=\"WebGL.html#.glInitPostProcess\">WebGL &rtrif; glInitPostProcess</a>"},{"title":"WebGL.glInitPostProcess","link":"<a href=\"WebGL.html#.glInitPostProcess\">WebGL &rtrif; glInitPostProcess</a>"},{"title":"WebGL.glSetBlendMode","link":"<a href=\"WebGL.html#.glSetBlendMode\">WebGL &rtrif; glSetBlendMode</a>"},{"title":"WebGL.glSetBlendMode","link":"<a href=\"WebGL.html#.glSetBlendMode\">WebGL &rtrif; glSetBlendMode</a>"},{"title":"WebGL.glSetTexture","link":"<a href=\"WebGL.html#.glSetTexture\">WebGL &rtrif; glSetTexture</a>"},{"title":"WebGL.glSetTexture","link":"<a href=\"WebGL.html#.glSetTexture\">WebGL &rtrif; glSetTexture</a>"},{"title":"engineFontImage","link":"<a href=\"global.html#engineFontImage\">engineFontImage</a>"},{"title":"engineInit","link":"<a href=\"global.html#engineInit\">engineInit</a>"},{"title":"engineName","link":"<a href=\"global.html#engineName\">engineName</a>"},{"title":"engineObjects","link":"<a href=\"global.html#engineObjects\">engineObjects</a>"},{"title":"engineObjectsCallback","link":"<a href=\"global.html#engineObjectsCallback\">engineObjectsCallback</a>"},{"title":"engineObjectsCollide","link":"<a href=\"global.html#engineObjectsCollide\">engineObjectsCollide</a>"},{"title":"engineObjectsDestroy","link":"<a href=\"global.html#engineObjectsDestroy\">engineObjectsDestroy</a>"},{"title":"engineObjectsUpdate","link":"<a href=\"global.html#engineObjectsUpdate\">engineObjectsUpdate</a>"},{"title":"engineVersion","link":"<a href=\"global.html#engineVersion\">engineVersion</a>"},{"title":"frame","link":"<a href=\"global.html#frame\">frame</a>"},{"title":"frameRate","link":"<a href=\"global.html#frameRate\">frameRate</a>"},{"title":"paused","link":"<a href=\"global.html#paused\">paused</a>"},{"title":"time","link":"<a href=\"global.html#time\">time</a>"},{"title":"timeDelta","link":"<a href=\"global.html#timeDelta\">timeDelta</a>"},{"title":"timeReal","link":"<a href=\"global.html#timeReal\">timeReal</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    


  </body>

</html>
